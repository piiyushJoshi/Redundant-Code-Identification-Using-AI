[
    {
        "original_code": "def process_data(data_list):\n    result = []\n    for item in data_list:\n        if isinstance(item, (int, float)):\n            result.append(item * 2)\n        elif isinstance(item, str):\n            result.append(item.upper())\n        else:\n            result.append(str(item))\n    return result",
        "comparison_code": "def transform_list(input_list):\n    output = []\n    for element in input_list:\n        if type(element) in [int, float]:\n            output.append(element * 2)\n        elif type(element) == str:\n            output.append(element.upper())\n        else:\n            output.append(str(element))\n    return output",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 9,
            "comparison_loc": 9,
            "differences": [
                "function_name",
                "variable_names",
                "type_checking_method"
            ]
        },
        "id": "1"
    },
    {
        "original_code": "def find_maximum(numbers):\n    max_value = numbers[0]\n    for num in numbers:\n        if num > max_value:\n            max_value = num\n    return max_value",
        "comparison_code": "def get_largest_value(values):\n    largest = values[0]\n    for val in values:\n        if val > largest:\n            largest = val\n    return largest",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 6,
            "comparison_loc": 6,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "2"
    },
    {
        "original_code": "def calculate_sum(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total",
        "comparison_code": "def get_total(values):\n    return sum(values)",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate",
        "complexity_score": 2,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 5,
            "comparison_loc": 2
        },
        "id": "3"
    },
    {
        "original_code": "def calculate_fibonacci(n):\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[-1]",
        "comparison_code": "def fibonacci_number(index):\n    sequence = [0, 1]\n    for i in range(2, index + 1):\n        sequence.append(sequence[i - 1] + sequence[i - 2])\n    return sequence[-1]",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 5,
            "comparison_loc": 5,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "4"
    },
    {
        "original_code": "\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    vector<int> merge_sort(vector<int> &arr) {\n        if (arr.size() <= 1) return arr;\n        int mid = arr.size() / 2;\n        vector<int> left(arr.begin(), arr.begin() + mid);\n        vector<int> right(arr.begin() + mid, arr.end());\n        return merge(merge_sort(left), merge_sort(right));\n    }\n\n    vector<int> merge(vector<int> &left, vector<int> &right) {\n        vector<int> sorted;\n        auto it_left = left.begin();\n        auto it_right = right.begin();\n        while (it_left != left.end() && it_right != right.end()) {\n            if (*it_left < *it_right) {\n                sorted.push_back(*it_left++);\n            } else {\n                sorted.push_back(*it_right++);\n            }\n        }\n        sorted.insert(sorted.end(), it_left, left.end());\n        sorted.insert(sorted.end(), it_right, right.end());\n        return sorted;\n    }",
        "comparison_code": "\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    vector<int> divide_and_merge(vector<int> &array) {\n        if (array.size() <= 1) return array;\n        int middle = array.size() / 2;\n        vector<int> left(array.begin(), array.begin() + middle);\n        vector<int> right(array.begin() + middle, array.end());\n        return combine(divide_and_merge(left), divide_and_merge(right));\n    }\n\n    vector<int> combine(vector<int> &left, vector<int> &right) {\n        vector<int> result;\n        auto l = left.begin();\n        auto r = right.begin();\n        while (l != left.end() && r != right.end()) {\n            if (*l < *r) {\n                result.push_back(*l++);\n            } else {\n                result.push_back(*r++);\n            }\n        }\n        result.insert(result.end(), l, left.end());\n        result.insert(result.end(), r, right.end());\n        return result;\n    }",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 26,
            "comparison_loc": 26,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "5"
    },
    {
        "original_code": "\n    #include <stdio.h>\n\n    int binary_search(int arr[], int size, int target) {\n        int low = 0, high = size - 1, mid;\n        while (low <= high) {\n            mid = low + (high - low) / 2;\n            if (arr[mid] == target)\n                return mid;\n            if (arr[mid] < target)\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        return -1;\n    }",
        "comparison_code": "\n    #include <stdio.h>\n\n    int search_in_sorted_array(int array[], int length, int value) {\n        int start = 0, end = length - 1, middle;\n        while (start <= end) {\n            middle = start + (end - start) / 2;\n            if (array[middle] == value)\n                return middle;\n            if (array[middle] < value)\n                start = middle + 1;\n            else\n                end = middle - 1;\n        }\n        return -1;\n    }",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 13,
            "comparison_loc": 13,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "6"
    },
    {
        "original_code": "\n    public class Factorial {\n        public static int factorial(int n) {\n            if (n == 0 || n == 1) return 1;\n            return n * factorial(n - 1);\n        }\n    }",
        "comparison_code": "\n    public class ComputeFactorial {\n        public static int findFactorial(int number) {\n            if (number <= 1) return 1;\n            return number * findFactorial(number - 1);\n        }\n    }",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 5,
            "comparison_loc": 5,
            "differences": [
                "class_name",
                "function_name",
                "variable_names"
            ]
        },
        "id": "7"
    },
    {
        "original_code": "def merge_sort(arr):\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            left_half = arr[:mid]\n            right_half = arr[mid:]\n            left_half = merge_sort(left_half)\n            right_half = merge_sort(right_half)\n            return merge(left_half, right_half)\n\n        def merge(left, right):\n            merged = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    merged.append(left[i])\n                    i += 1\n                else:\n                    merged.append(right[j])\n                    j += 1\n            merged.extend(left[i:])\n            merged.extend(right[j:])\n            return merged",
        "comparison_code": "def sort_array(array):\n            if len(array) <= 1:\n                return array\n            mid = len(array) // 2\n            left_part = array[:mid]\n            right_part = array[mid:]\n            left_part = sort_array(left_part)\n            right_part = sort_array(right_part)\n            return merge_arrays(left_part, right_part)\n\n        def merge_arrays(left, right):\n            merged = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    merged.append(left[i])\n                    i += 1\n                else:\n                    merged.append(right[j])\n                    j += 1\n            merged.extend(left[i:])\n            merged.extend(right[j:])\n            return merged",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "8"
    },
    {
        "original_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> filter_even(const vector<int>& nums) {\n    vector<int> result;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "comparison_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> get_even_numbers(const vector<int>& numbers) {\n    vector<int> evens;\n    for (int number : numbers) {\n        if (number % 2 == 0) {\n            evens.push_back(number);\n        }\n    }\n    return evens;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 11,
            "comparison_loc": 11,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "9"
    },
    {
        "original_code": "#include <stdio.h>\nvoid reverse_array(int arr[], int size) {\n    for (int i = 0; i < size / 2; i++) {\n        int temp = arr[i];\n        arr[i] = arr[size - i - 1];\n        arr[size - i - 1] = temp;\n    }\n}",
        "comparison_code": "#include <stdio.h>\nvoid reverse_elements(int array[], int length) {\n    int temp;\n    for (int i = 0; i < length / 2; i++) {\n        temp = array[i];\n        array[i] = array[length - i - 1];\n        array[length - i - 1] = temp;\n    }\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 7,
            "comparison_loc": 8,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "10"
    },
    {
        "original_code": "import java.util.*;\npublic class ListSorter {\n    public static List<Integer> sortListAscending(List<Integer> list) {\n        Collections.sort(list);\n        return list;\n    }\n}",
        "comparison_code": "import java.util.*;\npublic class SortUtils {\n    public static List<Integer> sortAscending(List<Integer> numbers) {\n        Collections.sort(numbers);\n        return numbers;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 6,
            "comparison_loc": 6,
            "differences": [
                "class_name",
                "function_name",
                "variable_names"
            ]
        },
        "id": "11"
    },
    {
        "original_code": "function flattenArray(arr) {\n    return arr.reduce((flat, current) => flat.concat(Array.isArray(current) ? flattenArray(current) : current), []);\n}",
        "comparison_code": "function collapseArray(array) {\n    return array.reduce((result, item) => result.concat(Array.isArray(item) ? collapseArray(item) : item), []);\n}",
        "is_redundant": true,
        "language": "javascript",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 2,
            "comparison_loc": 2,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "12"
    },
    {
        "original_code": "def dijkstra(graph, start):\n    import heapq\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances",
        "comparison_code": "def shortest_path(graph, source):\n    import heapq\n    min_distances = {node: float('inf') for node in graph}\n    min_distances[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        dist, current_node = heapq.heappop(pq)\n\n        if dist > min_distances[current_node]:\n            continue\n\n        for adj_node, edge_weight in graph[current_node].items():\n            new_dist = dist + edge_weight\n            if new_dist < min_distances[adj_node]:\n                min_distances[adj_node] = new_dist\n                heapq.heappush(pq, (new_dist, adj_node))\n\n    return min_distances",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 16,
            "comparison_loc": 16,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "13"
    },
    {
        "original_code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvoid floydWarshall(vector<vector<int>>& graph, int V) {\n    vector<vector<int>> dist = graph;\n\n    for (int k = 0; k < V; ++k) {\n        for (int i = 0; i < V; ++i) {\n            for (int j = 0; j < V; ++j) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < V; ++i) {\n        for (int j = 0; j < V; ++j) {\n            if (dist[i][j] == INT_MAX)\n                cout << \"INF \";\n            else\n                cout << dist[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}",
        "comparison_code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvoid findShortestPaths(vector<vector<int>>& adjMatrix, int n) {\n    vector<vector<int>> distance = adjMatrix;\n\n    for (int mid = 0; mid < n; ++mid) {\n        for (int start = 0; start < n; ++start) {\n            for (int end = 0; end < n; ++end) {\n                if (distance[start][mid] != INT_MAX && distance[mid][end] != INT_MAX &&\n                    distance[start][mid] + distance[mid][end] < distance[start][end]) {\n                    distance[start][end] = distance[start][mid] + distance[mid][end];\n                }\n            }\n        }\n    }\n\n    for (int a = 0; a < n; ++a) {\n        for (int b = 0; b < n; ++b) {\n            if (distance[a][b] == INT_MAX)\n                cout << \"INF \";\n            else\n                cout << distance[a][b] << \" \";\n        }\n        cout << endl;\n    }\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "variable names",
                "loop variable naming"
            ]
        },
        "id": "14"
    },
    {
        "original_code": "#include <stdio.h>\n#define MAX 100\n\nvoid knapsack(int n, int w[], int v[], int W) {\n    int dp[MAX][MAX] = {0};\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= W; j++) {\n            if (w[i - 1] <= j) {\n                dp[i][j] = (v[i - 1] + dp[i - 1][j - w[i - 1]] > dp[i - 1][j]) ? v[i - 1] + dp[i - 1][j - w[i - 1]] : dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    printf(\"Max Value: %d\\n\", dp[n][W]);\n}",
        "comparison_code": "#include <stdio.h>\n#define MAX 100\n\nvoid solveKnapsack(int items, int weights[], int values[], int capacity) {\n    int table[MAX][MAX] = {0};\n    for (int item = 1; item <= items; item++) {\n        for (int cap = 0; cap <= capacity; cap++) {\n            if (weights[item - 1] <= cap) {\n                table[item][cap] = (values[item - 1] + table[item - 1][cap - weights[item - 1]] > table[item - 1][cap]) ? values[item - 1] + table[item - 1][cap - weights[item - 1]] : table[item - 1][cap];\n            } else {\n                table[item][cap] = table[item - 1][cap];\n            }\n        }\n    }\n    printf(\"Optimal Value: %d\\n\", table[items][capacity]);\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "function name",
                "variable names"
            ]
        },
        "id": "15"
    },
    {
        "original_code": "def find_subsets(nums):\n    result = [[]]\n    for num in nums:\n        result += [current + [num] for current in result]\n    return result",
        "comparison_code": "def generate_combinations(elements):\n    subsets = [[]]\n    for element in elements:\n        subsets.extend([subset + [element] for subset in subsets])\n    return subsets",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 5,
            "comparison_loc": 5,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "16"
    },
    {
        "original_code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid reverseString(string &str) {\n    int n = str.length();\n    for (int i = 0; i < n / 2; i++) {\n        swap(str[i], str[n - i - 1]);\n    }\n}\n\nint main() {\n    string input;\n    cout << \"Enter a string: \";\n    cin >> input;\n    reverseString(input);\n    cout << \"Reversed string: \" << input << endl;\n    return 0;\n}",
        "comparison_code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid reverseWord(string &word) {\n    int len = word.size();\n    for (int i = 0; i < len / 2; i++) {\n        swap(word[i], word[len - i - 1]);\n    }\n}\n\nint main() {\n    string text;\n    cout << \"Input text: \";\n    cin >> text;\n    reverseWord(text);\n    cout << \"Flipped text: \" << text << endl;\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 14,
            "comparison_loc": 14,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "17"
    },
    {
        "original_code": "#include <stdio.h>\n\nvoid factorial(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    printf(\"Factorial: %d\\n\", result);\n}\n\nint main() {\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n    factorial(num);\n    return 0;\n}",
        "comparison_code": "#include <stdio.h>\n\nvoid computeFactorial(int x) {\n    int fact = 1;\n    for (int i = 1; i <= x; i++) {\n        fact *= i;\n    }\n    printf(\"Result: %d\\n\", fact);\n}\n\nint main() {\n    int value;\n    printf(\"Input value: \");\n    scanf(\"%d\", &value);\n    computeFactorial(value);\n    return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 13,
            "comparison_loc": 13,
            "differences": [
                "function_names",
                "variable names"
            ]
        },
        "id": "18"
    },
    {
        "original_code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "comparison_code": "def search_element(data, key):\n    start, end = 0, len(data) - 1\n    while start <= end:\n        middle = (start + end) // 2\n        if data[middle] == key:\n            return middle\n        elif data[middle] < key:\n            start = middle + 1\n        else:\n            end = middle - 1\n    return -1",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 10,
            "comparison_loc": 10,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "19"
    },
    {
        "original_code": "#include <iostream>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int num;\n    cout << \"Enter a number: \";\n    cin >> num;\n    if (isPrime(num)) {\n        cout << \"Prime\" << endl;\n    } else {\n        cout << \"Not Prime\" << endl;\n    }\n    return 0;\n}",
        "comparison_code": "#include <iostream>\nusing namespace std;\n\nbool checkPrime(int number) {\n    if (number <= 1) return false;\n    for (int div = 2; div * div <= number; div++) {\n        if (number % div == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int value;\n    cout << \"Input a value: \";\n    cin >> value;\n    if (checkPrime(value)) {\n        cout << \"It's a prime number!\" << endl;\n    } else {\n        cout << \"Not a prime number.\" << endl;\n    }\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 15,
            "comparison_loc": 15,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "20"
    },
    {
        "original_code": "#include <iostream>\nusing namespace std;\n\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(x, y);\n    cout << x << \" \" << y;\n    return 0;\n}",
        "comparison_code": "#include <iostream>\nusing namespace std;\n\nvoid exchange(int &p, int &q) {\n    int temp = p;\n    p = q;\n    q = temp;\n}\n\nint main() {\n    int num1 = 20, num2 = 40;\n    exchange(num1, num2);\n    cout << num1 << \" \" << num2;\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 12,
            "comparison_loc": 12,
            "differences": [
                "function_names",
                "variable_names",
                "input values"
            ]
        },
        "id": "21"
    },
    {
        "original_code": "public class Factorial {\n    public static int factorial(int n) {\n        if (n == 0) return 1;\n        return n * factorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int num = 5;\n        System.out.println(factorial(num));\n    }\n}",
        "comparison_code": "public class RecursiveFactorial {\n    public static int computeFactorial(int num) {\n        if (num == 0) return 1;\n        return num * computeFactorial(num - 1);\n    }\n\n    public static void main(String[] args) {\n        int value = 6;\n        System.out.println(computeFactorial(value));\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 9,
            "comparison_loc": 9,
            "differences": [
                "function_names",
                "variable_names",
                "parameter values"
            ]
        },
        "id": "22"
    },
    {
        "original_code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]",
        "comparison_code": "def sort_bubble(nums):\n    size = len(nums)\n    for idx in range(size):\n        for pos in range(0, size - idx - 1):\n            if nums[pos] > nums[pos + 1]:\n                nums[pos], nums[pos + 1] = nums[pos + 1], nums[pos]",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 7,
            "comparison_loc": 7,
            "differences": [
                "function_names",
                "variable_names"
            ]
        },
        "id": "23"
    },
    {
        "original_code": "#include <stdio.h>\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    printArray(arr, 5);\n    return 0;\n}",
        "comparison_code": "#include <stdio.h>\n\nvoid displayArray(int data[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", data[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int numbers[] = {10, 20, 30, 40};\n    displayArray(numbers, 4);\n    return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 11,
            "comparison_loc": 11,
            "differences": [
                "function_names",
                "variable_names",
                "array elements"
            ]
        },
        "id": "24"
    },
    {
        "original_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    double a = 3.0, b = 4.0;\n    cout << sqrt(a * a + b * b);\n    return 0;\n}",
        "comparison_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    double x = 6.0, y = 8.0;\n    cout << hypot(x, y);\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 7,
            "comparison_loc": 7,
            "differences": [
                "variable names",
                "mathematical function"
            ]
        },
        "id": "25"
    },
    {
        "original_code": "#include <stdio.h>\n\nint sum(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int x = 5, y = 10;\n    printf(\"%d\", sum(x, y));\n    return 0;\n}",
        "comparison_code": "#include <stdio.h>\n\nint add(int num1, int num2) {\n    return num1 + num2;\n}\n\nint main() {\n    int a = 3, b = 7;\n    printf(\"%d\", add(a, b));\n    return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 8,
            "comparison_loc": 8,
            "differences": [
                "function_names",
                "variable names",
                "input values"
            ]
        },
        "id": "26"
    },
    {
        "original_code": "public class SumArray {\n    public static int sum(int[] arr) {\n        int total = 0;\n        for (int val : arr) {\n            total += val;\n        }\n        return total;\n    }\n}",
        "comparison_code": "public class ArraySum {\n    public static int calculateSum(int[] numbers) {\n        int sum = 0;\n        for (int num : numbers) {\n            sum += num;\n        }\n        return sum;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 7,
            "comparison_loc": 7,
            "differences": [
                "class names",
                "function names",
                "variable names"
            ]
        },
        "id": "27"
    },
    {
        "original_code": "public class Palindrome {\n    public static boolean isPalindrome(String str) {\n        int n = str.length();\n        for (int i = 0; i < n / 2; i++) {\n            if (str.charAt(i) != str.charAt(n - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "comparison_code": "public class CheckPalindrome {\n    public static boolean checkIfPalindrome(String s) {\n        int len = s.length();\n        for (int index = 0; index < len / 2; index++) {\n            if (s.charAt(index) != s.charAt(len - index - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 4,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 9,
            "comparison_loc": 9,
            "differences": [
                "class names",
                "function names",
                "variable names"
            ]
        },
        "id": "28"
    },
    {
        "original_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sumArray(vector<int> nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    return sum;\n}\n\nint main() {\n    vector<int> numbers = {1, 2, 3, 4};\n    cout << sumArray(numbers) << endl;\n    return 0;\n}",
        "comparison_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint calculateSum(vector<int> values) {\n    int total = 0;\n    for (int val : values) {\n        total += val;\n    }\n    return total;\n}\n\nint main() {\n    vector<int> nums = {5, 6, 7, 8};\n    cout << calculateSum(nums) << endl;\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 11,
            "comparison_loc": 11,
            "differences": [
                "function_names",
                "variable names",
                "input values"
            ]
        },
        "id": "29"
    },
    {
        "original_code": "class Solution {\npublic:\n\n    string convert(string s, int numRows) {\n    \n    if(numRows <= 1) return s;\n\n    vector<string>v(numRows, \"\"); \n\n    int j = 0, dir = -1;\n\n    for(int i = 0; i < s.length(); i++)\n    {\n\n        if(j == numRows - 1 || j == 0) dir *= (-1); \n\n        v[j] += s[i];\n\n        if(dir == 1) j++;\n\n        else j--;\n    }\n\n    string res;\n\n    for(auto &it : v) res += it; \n\n    return res;\n\n    }\n};",
        "comparison_code": "class Solution {\npublic:\n\n    string zigzagConvert(string s, int rows) {\n    \n    if(rows <= 1) return s;\n\n    vector<string> lines(rows, \"\"); \n\n    int index = 0, direction = -1;\n\n    for(int i = 0; i < s.length(); i++)\n    {\n\n        if(index == rows - 1 || index == 0) direction *= (-1); \n\n        lines[index] += s[i];\n\n        if(direction == 1) index++;\n\n        else index--;\n    }\n\n    string result;\n\n    for(auto &line : lines) result += line; \n\n    return result;\n\n    }\n};",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 16,
            "comparison_loc": 16,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "30"
    },
    {
        "original_code": "class Solution {\n    private static final String[] PHONE_MAP = {\n            \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n    };\n\n    public List<String> letterCombinations(String digits) {\n        List<String> combinations = new ArrayList<>();\n\n        if (digits.isEmpty())\n            return combinations;\n\n        backtrack(0, digits, new StringBuilder(), combinations);\n\n        return combinations;\n    }\n\n    private void backtrack(int index, String digits, StringBuilder path, List<String> combinations) {\n        if (index == digits.length()) {\n            combinations.add(path.toString());\n\n            return;\n        }\n\n        String possibleLetters = PHONE_MAP[digits.charAt(index) - '0'];\n\n        for (char letter : possibleLetters.toCharArray()) {\n            path.append(letter);\n\n            backtrack(index + 1, digits, path, combinations);\n\n            path.deleteCharAt(path.length() - 1); // Backtrack\n        }\n    }\n}",
        "comparison_code": "class Solution {\n    private static final String[] NUMERIC_MAP = {\n            \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n    };\n\n    public List<String> generateCombinations(String input) {\n        List<String> result = new ArrayList<>();\n\n        if (input.isEmpty())\n            return result;\n\n        generate(0, input, new StringBuilder(), result);\n\n        return result;\n    }\n\n    private void generate(int pos, String input, StringBuilder currentCombination, List<String> result) {\n        if (pos == input.length()) {\n            result.add(currentCombination.toString());\n\n            return;\n        }\n\n        String letters = NUMERIC_MAP[input.charAt(pos) - '0'];\n\n        for (char ch : letters.toCharArray()) {\n            currentCombination.append(ch);\n\n            generate(pos + 1, input, currentCombination, result);\n\n            currentCombination.deleteCharAt(currentCombination.length() - 1); // Undo step\n        }\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 23,
            "comparison_loc": 23,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "31"
    },
    {
        "original_code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function (head, k) {\n    const dummy = new LinkedListNode(0);\n    dummy.next = head;\n    let ptr = dummy;\n\n    while (ptr !== null) {\n\n        let tracker = ptr;\n\n        for (let i = 0; i < k; i++) {\n            if (tracker === null) {\n                break;\n            }\n            tracker = tracker.next;\n        }\n\n        if (tracker === null) {\n            break;\n        }\n\n        const updatedNodes = reverseLinkedList(ptr.next, k);\n        const previous = updatedNodes[0];\n        const current = updatedNodes[1];\n\n        const lastNodeOfReversedGroup = ptr.next;\n        lastNodeOfReversedGroup.next = current;\n        ptr.next = previous;\n        ptr = lastNodeOfReversedGroup;\n    }\n\n    return dummy.next;\n};\n\nclass LinkedListNode {\n    constructor(data, next = null) {\n        this.data = data;\n        this.next = next;\n    }\n}\n\nfunction reverseLinkedList(head, k) {\n\n    let previous = null;\n    let current = head;\n    let next = null;\n\n    for (let i = 0; i < k; i++) {\n        // temporarily store the next node\n        next = current.next;\n        // reverse the current node\n        current.next = previous;\n        // before we move to the next node, point previous to the current node\n        previous = current;\n        // move to the next node\n        current = next;\n    }\n\n    return [previous, current];\n}",
        "comparison_code": "/**\n * Definition for singly-linked list.\n * function ListNode(value, next) {\n *     this.value = (value === undefined ? 0 : value)\n *     this.next = (next === undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function (head, k) {\n    const startNode = new LinkedListNode(0);\n    startNode.next = head;\n    let currentNode = startNode;\n\n    while (currentNode !== null) {\n\n        let tempNode = currentNode;\n\n        for (let i = 0; i < k; i++) {\n            if (tempNode === null) {\n                break;\n            }\n            tempNode = tempNode.next;\n        }\n\n        if (tempNode === null) {\n            break;\n        }\n\n        const reversedNodes = reverseList(tempNode.next, k);\n        const previousNode = reversedNodes[0];\n        const nextNode = reversedNodes[1];\n\n        const lastReversedNode = currentNode.next;\n        lastReversedNode.next = nextNode;\n        currentNode.next = previousNode;\n        currentNode = lastReversedNode;\n    }\n\n    return startNode.next;\n};\n\nclass LinkedListNode {\n    constructor(value, next = null) {\n        this.value = value;\n        this.next = next;\n    }\n}\n\nfunction reverseList(head, k) {\n\n    let prev = null;\n    let curr = head;\n    let nxt = null;\n\n    for (let i = 0; i < k; i++) {\n        nxt = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nxt;\n    }\n\n    return [prev, curr];\n}",
        "is_redundant": true,
        "language": "javascript",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 28,
            "comparison_loc": 28,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "32"
    },
    {
        "original_code": "public class Solution {\n    public int Trap(int[] height) {\n        int maxPeak = 0;\n        int maxPeakIndex = 0;\n        for (int i = 0; i < height.Length; i ++)\n            if (height[i] > maxPeak)\n            {\n                maxPeak = height[i];\n                maxPeakIndex = i;\n            }\n\n        int totalWater = 0;\n        int currentElevation = 0;\n        for (int i = 0; i < maxPeakIndex; i ++)\n        {\n            currentElevation = height[i];\n            for (int j = i+1; j < height.Length && height[j] < currentElevation; j++)\n            {\n                totalWater += currentElevation - height[j];\n                i ++;\n            }\n        }\n        for (int i = height.Length-1; i > maxPeakIndex; i --)\n        {\n            currentElevation = height[i];\n            for (int j = i-1; j > maxPeakIndex && height[j] < currentElevation; j--)\n            {\n                totalWater += currentElevation - height[j];\n                i --;\n            }\n        }\n        return totalWater;\n    }\n}",
        "comparison_code": "public class Solution {\n    public int CalculateWater(int[] heights) {\n        int highestPeak = 0;\n        int peakIndex = 0;\n        for (int i = 0; i < heights.Length; i++)\n            if (heights[i] > highestPeak)\n            {\n                highestPeak = heights[i];\n                peakIndex = i;\n            }\n\n        int totalWater = 0;\n        int currentHeight = 0;\n        for (int i = 0; i < peakIndex; i++)\n        {\n            currentHeight = heights[i];\n            for (int j = i + 1; j < heights.Length && heights[j] < currentHeight; j++)\n            {\n                totalWater += currentHeight - heights[j];\n                i++;\n            }\n        }\n        for (int i = heights.Length - 1; i > peakIndex; i--)\n        {\n            currentHeight = heights[i];\n            for (int j = i - 1; j > peakIndex && heights[j] < currentHeight; j--)\n            {\n                totalWater += currentHeight - heights[j];\n                i--;\n            }\n        }\n        return totalWater;\n    }\n}",
        "is_redundant": true,
        "language": "c#",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 26,
            "comparison_loc": 26,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "33"
    },
    {
        "original_code": "class Solution {\npublic:\n\n    bool isMatch(string s, string p) {\n        int n=s.length(),m=p.length();\n       \n       vector<bool>prev(m+1,false),cur(m+1,false);\n\n        prev[0]=true;\n        \n        for(int i=1;i<=m;i++)\n        {\n            if(p[i-1]=='*')\n                prev[i]=true;\n            else \n                break;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                if(s[i-1]==p[j-1] || p[j-1]=='?')\n                    cur[j]=prev[j-1];\n                else if(p[j-1]=='*')\n                    cur[j]=cur[j-1] || prev[j];\n                else\n                    cur[j]=false;\n            }\n            prev=cur;\n        }\n        return prev[m];\n    }\n};",
        "comparison_code": "class Solution {\npublic:\n\n    bool matchPattern(string s, string p) {\n        int lenS = s.length(), lenP = p.length();\n       \n       vector<bool> prevRow(lenP + 1, false), currRow(lenP + 1, false);\n\n        prevRow[0] = true;\n        \n        for (int i = 1; i <= lenP; i++)\n        {\n            if (p[i - 1] == '*')\n                prevRow[i] = true;\n            else\n                break;\n        }\n        for (int i = 1; i <= lenS; i++)\n        {\n            for (int j = 1; j <= lenP; j++)\n            {\n                if (s[i - 1] == p[j - 1] || p[j - 1] == '?')\n                    currRow[j] = prevRow[j - 1];\n                else if (p[j - 1] == '*')\n                    currRow[j] = currRow[j - 1] || prevRow[j];\n                else\n                    currRow[j] = false;\n            }\n            prevRow = currRow;\n        }\n        return prevRow[lenP];\n    }\n};",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 22,
            "comparison_loc": 22,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "34"
    },
    {
        "original_code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
        "comparison_code": "def sorted_merge(arr):\n    if len(arr) <= 1:\n        return arr\n    middle = len(arr) // 2\n    left_half = sorted_merge(arr[:middle])\n    right_half = sorted_merge(arr[middle:])\n    return combine(left_half, right_half)\n\ndef combine(left, right):\n    merged = []\n    l_index, r_index = 0, 0\n    while l_index < len(left) and r_index < len(right):\n        if left[l_index] <= right[r_index]:\n            merged.append(left[l_index])\n            l_index += 1\n        else:\n            merged.append(right[r_index])\n            r_index += 1\n    merged.extend(left[l_index:])\n    merged.extend(right[r_index:])\n    return merged",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 18,
            "comparison_loc": 18,
            "differences": [
                "function_names",
                "variable_names",
                "minor_logic_modifications"
            ]
        },
        "id": "35"
    },
    {
        "original_code": "class QuickSort {\n    public void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            int partitionIndex = partition(arr, low, high);\n            quickSort(arr, low, partitionIndex - 1);\n            quickSort(arr, partitionIndex + 1, high);\n        }\n    }\n\n    private int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n}",
        "comparison_code": "class ArraySorter {\n    public void performQuickSort(int[] arr, int start, int end) {\n        if (start < end) {\n            int pivotPosition = divideArray(arr, start, end);\n            performQuickSort(arr, start, pivotPosition - 1);\n            performQuickSort(arr, pivotPosition + 1, end);\n        }\n    }\n\n    private int divideArray(int[] arr, int start, int end) {\n        int pivotElement = arr[end];\n        int index = start - 1;\n        for (int j = start; j < end; j++) {\n            if (arr[j] <= pivotElement) {\n                index++;\n                int swap = arr[index];\n                arr[index] = arr[j];\n                arr[j] = swap;\n            }\n        }\n        int swap = arr[index + 1];\n        arr[index + 1] = arr[end];\n        arr[end] = swap;\n        return index + 1;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "class_names",
                "method_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "36"
    },
    {
        "original_code": "#include <vector>\nusing namespace std;\n\nclass BinarySearchTree {\nprivate:\n    struct Node {\n        int data;\n        Node* left;\n        Node* right;\n        Node(int val) : data(val), left(nullptr), right(nullptr) {}\n    };\n    Node* root;\n\n    Node* insertNode(Node* node, int value) {\n        if (node == nullptr) return new Node(value);\n        if (value < node->data)\n            node->left = insertNode(node->left, value);\n        else if (value > node->data)\n            node->right = insertNode(node->right, value);\n        return node;\n    }\n\npublic:\n    BinarySearchTree() : root(nullptr) {}\n\n    void insert(int value) {\n        root = insertNode(root, value);\n    }\n}",
        "comparison_code": "#include <vector>\nusing namespace std;\n\nclass TreeStructure {\nprivate:\n    struct TreeNode {\n        int value;\n        TreeNode* leftChild;\n        TreeNode* rightChild;\n        TreeNode(int val) : value(val), leftChild(nullptr), rightChild(nullptr) {}\n    };\n    TreeNode* rootNode;\n\n    TreeNode* addNode(TreeNode* node, int key) {\n        if (node == nullptr) return new TreeNode(key);\n        if (key < node->value)\n            node->leftChild = addNode(node->leftChild, key);\n        else if (key > node->value)\n            node->rightChild = addNode(node->rightChild, key);\n        return node;\n    }\n\npublic:\n    TreeStructure() : rootNode(nullptr) {}\n\n    void insertNode(int key) {\n        rootNode = addNode(rootNode, key);\n    }\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 22,
            "comparison_loc": 22,
            "differences": [
                "class_names",
                "struct_names",
                "method_names",
                "variable_names"
            ]
        },
        "id": "37"
    },
    {
        "original_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int data;\n    struct ListNode* next;\n};\n\nstruct ListNode* createNode(int value) {\n    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid insertAtEnd(struct ListNode** head, int value) {\n    struct ListNode* newNode = createNode(value);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    struct ListNode* current = *head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}",
        "comparison_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int value;\n    struct Node* link;\n};\n\nstruct Node* makeNode(int data) {\n    struct Node* newElement = (struct Node*)malloc(sizeof(struct Node));\n    newElement->value = data;\n    newElement->link = NULL;\n    return newElement;\n}\n\nvoid appendNode(struct Node** head, int data) {\n    struct Node* newElement = makeNode(data);\n    if (*head == NULL) {\n        *head = newElement;\n        return;\n    }\n    struct Node* current = *head;\n    while (current->link != NULL) {\n        current = current->link;\n    }\n    current->link = newElement;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "struct_names",
                "function_names",
                "variable_names"
            ]
        },
        "id": "38"
    },
    {
        "original_code": "def find_max_subarray(arr):\n    max_so_far = float('-inf')\n    max_ending_here = 0\n    start, end, s = 0, 0, 0\n\n    for i in range(len(arr)):\n        max_ending_here += arr[i]\n\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n            start = s\n            end = i\n\n        if max_ending_here < 0:\n            max_ending_here = 0\n            s = i + 1\n\n    return max_so_far, arr[start:end+1]",
        "comparison_code": "def maximum_subarray(arr):\n    current_max = float('-inf')\n    current_sum = 0\n    start_index, finish_index, temporary_start = 0, 0, 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n\n        if current_max < current_sum:\n            current_max = current_sum\n            start_index = temporary_start\n            finish_index = i\n\n        if current_sum < 0:\n            current_sum = 0\n            temporary_start = i + 1\n\n    return current_max, arr[start_index:finish_index+1]",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 18,
            "comparison_loc": 18,
            "differences": [
                "function_names",
                "variable_names",
                "minor_implementation_details"
            ]
        },
        "id": "39"
    },
    {
        "original_code": "import java.util.*;\n\nclass BreadthFirstSearch {\n    private Map<Integer, List<Integer>> graph;\n\n    public BreadthFirstSearch() {\n        graph = new HashMap<>();\n    }\n\n    public void addEdge(int node, int neighbor) {\n        graph.computeIfAbsent(node, k -> new ArrayList<>()).add(neighbor);\n    }\n\n    public List<Integer> bfs(int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> result = new ArrayList<>();\n\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            result.add(current);\n\n            for (int neighbor : graph.getOrDefault(current, Collections.emptyList())) {\n                if (!visited.contains(neighbor)) {\n                    queue.add(neighbor);\n                    visited.add(neighbor);\n                }\n            }\n        }\n\n        return result;\n    }\n}",
        "comparison_code": "import java.util.*;\n\nclass GraphTraversal {\n    private Map<Integer, List<Integer>> adjacencyList;\n\n    public GraphTraversal() {\n        adjacencyList = new HashMap<>();\n    }\n\n    public void connectNodes(int source, int destination) {\n        adjacencyList.computeIfAbsent(source, k -> new ArrayList<>()).add(destination);\n    }\n\n    public List<Integer> breadthFirstSearch(int startNode) {\n        Set<Integer> exploredNodes = new HashSet<>();\n        Queue<Integer> processingQueue = new LinkedList<>();\n        List<Integer> traversalOrder = new ArrayList<>();\n\n        processingQueue.add(startNode);\n        exploredNodes.add(startNode);\n\n        while (!processingQueue.isEmpty()) {\n            int currentNode = processingQueue.poll();\n            traversalOrder.add(currentNode);\n\n            for (int neighborNode : adjacencyList.getOrDefault(currentNode, Collections.emptyList())) {\n                if (!exploredNodes.contains(neighborNode)) {\n                    processingQueue.add(neighborNode);\n                    exploredNodes.add(neighborNode);\n                }\n            }\n        }\n\n        return traversalOrder;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 24,
            "comparison_loc": 24,
            "differences": [
                "class_names",
                "method_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "40"
    },
    {
        "original_code": "class Graph {\n    private int vertices;\n    private List<List<Integer>> adjacencyList;\n\n    public Graph(int v) {\n        vertices = v;\n        adjacencyList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int source, int destination) {\n        adjacencyList.get(source).add(destination);\n        adjacencyList.get(destination).add(source);\n    }\n\n    public boolean hasPath(int start, int end) {\n        boolean[] visited = new boolean[vertices];\n        return dfs(start, end, visited);\n    }\n\n    private boolean dfs(int current, int target, boolean[] visited) {\n        if (current == target) return true;\n        visited[current] = true;\n\n        for (int neighbor : adjacencyList.get(current)) {\n            if (!visited[neighbor]) {\n                if (dfs(neighbor, target, visited)) return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "comparison_code": "class GraphConnectivity {\n    private int nodeCount;\n    private List<List<Integer>> connections;\n\n    public GraphConnectivity(int totalNodes) {\n        nodeCount = totalNodes;\n        connections = new ArrayList<>(totalNodes);\n        for (int i = 0; i < totalNodes; i++) {\n            connections.add(new ArrayList<>());\n        }\n    }\n\n    public void connectNodes(int from, int to) {\n        connections.get(from).add(to);\n        connections.get(to).add(from);\n    }\n\n    public boolean findPath(int origin, int destination) {\n        boolean[] explored = new boolean[nodeCount];\n        return depthFirstSearch(origin, destination, explored);\n    }\n\n    private boolean depthFirstSearch(int current, int target, boolean[] explored) {\n        if (current == target) return true;\n        explored[current] = true;\n\n        for (int adjacentNode : connections.get(current)) {\n            if (!explored[adjacentNode]) {\n                if (depthFirstSearch(adjacentNode, target, explored)) return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 22,
            "comparison_loc": 22,
            "differences": [
                "class_names",
                "method_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "41"
    },
    {
        "original_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MatrixMultiplication {\npublic:\n    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\n        int rowsA = A.size();\n        int colsA = A[0].size();\n        int colsB = B[0].size();\n\n        vector<vector<int>> result(rowsA, vector<int>(colsB, 0));\n\n        for (int i = 0; i < rowsA; i++) {\n            for (int j = 0; j < colsB; j++) {\n                for (int k = 0; k < colsA; k++) {\n                    result[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n\n        return result;\n    }\n};",
        "comparison_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MatrixComputation {\npublic:\n    vector<vector<int>> multiplyMatrices(vector<vector<int>>& matrix1, vector<vector<int>>& matrix2) {\n        int rowCount = matrix1.size();\n        int colCountA = matrix1[0].size();\n        int colCountB = matrix2[0].size();\n\n        vector<vector<int>> outputMatrix(rowCount, vector<int>(colCountB, 0));\n\n        for (int row = 0; row < rowCount; row++) {\n            for (int col = 0; col < colCountB; col++) {\n                for (int inner = 0; inner < colCountA; inner++) {\n                    outputMatrix[row][col] += matrix1[row][inner] * matrix2[inner][col];\n                }\n            }\n        }\n\n        return outputMatrix;\n    }\n};",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "class_names",
                "method_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "42"
    },
    {
        "original_code": "def longest_common_subsequence(X, Y):\n    m = len(X)\n    n = len(Y)\n    \n    L = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    \n    return L[m][n]",
        "comparison_code": "def compute_lcs(sequence1, sequence2):\n    len1 = len(sequence1)\n    len2 = len(sequence2)\n    \n    dp_table = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    for row in range(1, len1 + 1):\n        for col in range(1, len2 + 1):\n            if sequence1[row-1] == sequence2[col-1]:\n                dp_table[row][col] = dp_table[row-1][col-1] + 1\n            else:\n                dp_table[row][col] = max(dp_table[row-1][col], dp_table[row][col-1])\n    \n    return dp_table[len1][len2]",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 18,
            "comparison_loc": 18,
            "differences": [
                "function_names",
                "variable_names",
                "minor_implementation_details"
            ]
        },
        "id": "43"
    },
    {
        "original_code": "public class RadixSort {\n    public static void radixSort(int[] arr) {\n        if (arr == null || arr.length == 0) return;\n        \n        int max = findMaxElement(arr);\n        \n        for (int exp = 1; max / exp > 0; exp *= 10) {\n            countingSort(arr, exp);\n        }\n    }\n    \n    private static void countingSort(int[] arr, int exp) {\n        int n = arr.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n        \n        for (int i = 0; i < n; i++) {\n            count[(arr[i] / exp) % 10]++;\n        }\n        \n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n    \n    private static int findMaxElement(int[] arr) {\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n}",
        "comparison_code": "public class ArrayRadixSort {\n    public static void performRadixSort(int[] elements) {\n        if (elements == null || elements.length == 0) return;\n        \n        int maxValue = locateMaximum(elements);\n        \n        for (int place = 1; maxValue / place > 0; place *= 10) {\n            stabilizedCountSort(elements, place);\n        }\n    }\n    \n    private static void stabilizedCountSort(int[] elements, int place) {\n        int length = elements.length;\n        int[] sortedArray = new int[length];\n        int[] frequencyCount = new int[10];\n        \n        for (int i = 0; i < length; i++) {\n            frequencyCount[(elements[i] / place) % 10]++;\n        }\n        \n        for (int i = 1; i < 10; i++) {\n            frequencyCount[i] += frequencyCount[i - 1];\n        }\n        \n        for (int i = length - 1; i >= 0; i--) {\n            sortedArray[frequencyCount[(elements[i] / place) % 10] - 1] = elements[i];\n            frequencyCount[(elements[i] / place) % 10]--;\n        }\n        \n        for (int i = 0; i < length; i++) {\n            elements[i] = sortedArray[i];\n        }\n    }\n    \n    private static int locateMaximum(int[] elements) {\n        int maximum = elements[0];\n        for (int i = 1; i < elements.length; i++) {\n            if (elements[i] > maximum) {\n                maximum = elements[i];\n            }\n        }\n        return maximum;\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 24,
            "comparison_loc": 24,
            "differences": [
                "class_names",
                "method_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "44"
    },
    {
        "original_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct TreeNode {\n    int data;\n    struct TreeNode* left;\n    struct TreeNode* right;\n};\n\nstruct TreeNode* createNode(int value) {\n    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    newNode->data = value;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nint getHeight(struct TreeNode* node) {\n    if (node == NULL) return 0;\n    \n    int leftHeight = getHeight(node->left);\n    int rightHeight = getHeight(node->right);\n    \n    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;\n}",
        "comparison_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int value;\n    struct Node* leftChild;\n    struct Node* rightChild;\n};\n\nstruct Node* makeNode(int data) {\n    struct Node* newElement = (struct Node*)malloc(sizeof(struct Node));\n    newElement->value = data;\n    newElement->leftChild = NULL;\n    newElement->rightChild = NULL;\n    return newElement;\n}\n\nint calculateHeight(struct Node* treeNode) {\n    if (treeNode == NULL) return 0;\n    \n    int leftSubtreeHeight = calculateHeight(treeNode->leftChild);\n    int rightSubtreeHeight = calculateHeight(treeNode->rightChild);\n    \n    return (leftSubtreeHeight > rightSubtreeHeight ? leftSubtreeHeight : rightSubtreeHeight) + 1;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "struct_names",
                "function_names",
                "variable_names"
            ]
        },
        "id": "45"
    },
    {
        "original_code": "def quick_select(arr, k):\n    def partition(left, right):\n        pivot = arr[right]\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot:\n                arr[store_index], arr[i] = arr[i], arr[store_index]\n                store_index += 1\n        arr[right], arr[store_index] = arr[store_index], arr[right]\n        return store_index\n    \n    def select(left, right):\n        if left == right:\n            return arr[left]\n        \n        pivotIndex = partition(left, right)\n        \n        if k == pivotIndex:\n            return arr[k]\n        elif k < pivotIndex:\n            return select(left, pivotIndex - 1)\n        else:\n            return select(pivotIndex + 1, right)\n    \n    return select(0, len(arr) - 1)",
        "comparison_code": "def kth_smallest(arr, k):\n    def array_partition(start, end):\n        pivot = arr[end]\n        insert_pos = start\n        for j in range(start, end):\n            if arr[j] < pivot:\n                arr[insert_pos], arr[j] = arr[j], arr[insert_pos]\n                insert_pos += 1\n        arr[end], arr[insert_pos] = arr[insert_pos], arr[end]\n        return insert_pos\n    \n    def find_kth(left, right):\n        if left == right:\n            return arr[left]\n        \n        pivotIndex = array_partition(left, right)\n        \n        if k == pivotIndex:\n            return arr[k]\n        elif k < pivotIndex:\n            return find_kth(left, pivotIndex - 1)\n        else:\n            return find_kth(pivotIndex + 1, right)\n    \n    return find_kth(0, len(arr) - 1)",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "function_names",
                "inner_function_names",
                "variable_names",
                "minor_implementation_details"
            ]
        },
        "id": "46"
    },
    {
        "original_code": "def binary_search_kth(arr, k):\n    def count_less_equal(mid):\n        return sum(1 for x in arr if x <= mid)\n    \n    left, right = min(arr), max(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
        "comparison_code": "def selection_by_range(arr, k):\n    def count_smaller(mid):\n        return sum(1 for x in arr if x < mid)\n    \n    start, end = min(arr), max(arr)\n    while start < end:\n        middle = (start + end) // 2\n        if count_smaller(middle) < k - 1:\n            start = middle + 1\n        else:\n            end = middle\n    return start",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 6,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 20,
            "comparison_loc": 20,
            "differences": [
                "function_names",
                "inner_function_names",
                "counting_logic"
            ]
        },
        "id": "47"
    },
    {
        "original_code": "#include <vector>\n#include <algorithm>\n\nint mergeBasedKthSelection(std::vector<int>& arr, int k) {\n    std::vector<int> temp = arr;\n    std::sort(temp.begin(), temp.end());\n    return temp[k-1];\n\n    auto merge = [](std::vector<int>& arr, int left, int mid, int right) {\n        std::vector<int> leftArr(arr.begin() + left, arr.begin() + mid + 1);\n        std::vector<int> rightArr(arr.begin() + mid + 1, arr.begin() + right + 1);\n        \n        int i = 0, j = 0, k = left;\n        while (i < leftArr.size() && j < rightArr.size()) {\n            if (leftArr[i] <= rightArr[j]) {\n                arr[k++] = leftArr[i++];\n            } else {\n                arr[k++] = rightArr[j++];\n            }\n        }\n        \n        while (i < leftArr.size()) arr[k++] = leftArr[i++];\n        while (j < rightArr.size()) arr[k++] = rightArr[j++];\n    };\n\n    auto mergeSort = [&](auto&& self, std::vector<int>& arr, int left, int right) -> void {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            self(self, arr, left, mid);\n            self(self, arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    };\n\n    return arr[k-1];\n}",
        "comparison_code": "#include <vector>\n#include <algorithm>\n\nint sortBasedKthElement(std::vector<int>& arr, int k) {\n    std::vector<int> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n    return sorted[k-1];\n\n    auto arrayMerge = [](std::vector<int>& arr, int left, int mid, int right) {\n        std::vector<int> leftSubarray(arr.begin() + left, arr.begin() + mid + 1);\n        std::vector<int> rightSubarray(arr.begin() + mid + 1, arr.begin() + right + 1);\n        \n        int i = 0, j = 0, k = left;\n        while (i < leftSubarray.size() && j < rightSubarray.size()) {\n            if (leftSubarray[i] <= rightSubarray[j]) {\n                arr[k++] = leftSubarray[i++];\n            } else {\n                arr[k++] = rightSubarray[j++];\n            }\n        }\n        \n        while (i < leftSubarray.size()) arr[k++] = leftSubarray[i++];\n        while (j < rightSubarray.size()) arr[k++] = rightSubarray[j++];\n    };\n\n    return arr[k-1];\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 7,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 25,
            "comparison_loc": 25,
            "differences": [
                "function_names",
                "variable_names",
                "lambda_function_names"
            ]
        },
        "id": "48"
    },
    {
        "original_code": "import java.util.PriorityQueue;\n\nclass KthSmallestFinder {\n    public static int findKthSmallest(int[] arr, int k) {\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n        \n        for (int num : arr) {\n            maxHeap.offer(num);\n            if (maxHeap.size() > k) {\n                maxHeap.poll();\n            }\n        }\n        \n        return maxHeap.peek();\n    }\n}",
        "comparison_code": "import java.util.PriorityQueue;\n\nclass KthElementSelector {\n    public static int selectKthElement(int[] arr, int k) {\n        PriorityQueue<Integer> priorityHeap = new PriorityQueue<>((a, b) -> b - a);\n        \n        for (int element : arr) {\n            priorityHeap.offer(element);\n            if (priorityHeap.size() > k) {\n                priorityHeap.poll();\n            }\n        }\n        \n        return priorityHeap.peek();\n    }\n}",
        "is_redundant": true,
        "language": "java",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 5,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 15,
            "comparison_loc": 15,
            "differences": [
                "class_names",
                "method_names",
                "variable_names"
            ]
        },
        "id": "49"
    },
    {
        "original_code": "int countingSortKthSmallest(int* arr, int n, int k) {\n    int max_val = arr[0];\n    int min_val = arr[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max_val) max_val = arr[i];\n        if (arr[i] < min_val) min_val = arr[i];\n    }\n    \n    int range = max_val - min_val + 1;\n    int* count = (int*)calloc(range, sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        count[arr[i] - min_val]++;\n    }\n    \n    int count_smaller = 0;\n    for (int i = 0; i < range; i++) {\n        int prev_count = count_smaller;\n        count_smaller += count[i];\n        \n        if (count_smaller >= k) {\n            int result = i + min_val;\n            free(count);\n            return result;\n        }\n    }\n    \n    free(count);\n    return -1;\n}",
        "comparison_code": "int selectKthElement(int* arr, int n, int k) {\n    int maximum = arr[0];\n    int minimum = arr[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] > maximum) maximum = arr[i];\n        if (arr[i] < minimum) minimum = arr[i];\n    }\n    \n    int value_range = maximum - minimum + 1;\n    int* frequency = (int*)calloc(value_range, sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        frequency[arr[i] - minimum]++;\n    }\n    \n    int cumulative_count = 0;\n    for (int i = 0; i < value_range; i++) {\n        int previous_count = cumulative_count;\n        cumulative_count += frequency[i];\n        \n        if (cumulative_count >= k) {\n            int result = i + minimum;\n            free(frequency);\n            return result;\n        }\n    }\n    \n    free(frequency);\n    return -1;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 25,
            "comparison_loc": 25,
            "differences": [
                "function_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "50"
    },
    {
        "original_code": "import random\n\ndef randomized_kth_selection(arr, k):\n    def partition(left, right):\n        pivot_index = random.randint(left, right)\n        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]\n        pivot = arr[right]\n        store_index = left\n        \n        for i in range(left, right):\n            if arr[i] < pivot:\n                arr[store_index], arr[i] = arr[i], arr[store_index]\n                store_index += 1\n        \n        arr[right], arr[store_index] = arr[store_index], arr[right]\n        return store_index\n    \n    def select(left, right):\n        if left == right:\n            return arr[left]\n        \n        pivot_index = partition(left, right)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(left, pivot_index - 1)\n        else:\n            return select(pivot_index + 1, right)\n    \n    return select(0, len(arr) - 1)",
        "comparison_code": "import random\n\ndef select_kth_element(arr, k):\n    def array_partition(start, end):\n        random_pivot = random.randint(start, end)\n        arr[random_pivot], arr[end] = arr[end], arr[random_pivot]\n        pivot = arr[end]\n        insert_pos = start\n        \n        for j in range(start, end):\n            if arr[j] < pivot:\n                arr[insert_pos], arr[j] = arr[j], arr[insert_pos]\n                insert_pos += 1\n        \n        arr[end], arr[insert_pos] = arr[insert_pos], arr[end]\n        return insert_pos\n    \n    def find_kth(left, right):\n        if left == right:\n            return arr[left]\n        \n        pivot_index = array_partition(left, right)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return find_kth(left, pivot_index - 1)\n        else:\n            return find_kth(pivot_index + 1, right)\n    \n    return find_kth(0, len(arr) - 1)",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 25,
            "comparison_loc": 25,
            "differences": [
                "function_names",
                "inner_function_names",
                "variable_names"
            ]
        },
        "id": "51"
    },
    {
        "original_code": "def divide_conquer_kth(arr, k):\n    def select_recursive(subarray, k):\n        if len(subarray) <= 5:\n            return sorted(subarray)[k]\n        \n        chunks = [subarray[i:i+5] for i in range(0, len(subarray), 5)]\n        medians = [sorted(chunk)[len(chunk)//2] for chunk in chunks]\n        \n        pivot = select_recursive(medians, len(medians)//2)\n        \n        left = [x for x in subarray if x < pivot]\n        equal = [x for x in subarray if x == pivot]\n        right = [x for x in subarray if x > pivot]\n        \n        if k < len(left):\n            return select_recursive(left, k)\n        elif k < len(left) + len(equal):\n            return pivot\n        else:\n            return select_recursive(right, k - len(left) - len(equal))\n    \n    return select_recursive(arr, k)",
        "comparison_code": "def kth_element_selector(arr, k):\n    def recursive_selection(subarray, k):\n        if len(subarray) <= 5:\n            return sorted(subarray)[k]\n        \n        divided_chunks = [subarray[i:i+5] for i in range(0, len(subarray), 5)]\n        median_values = [sorted(chunk)[len(chunk)//2] for chunk in divided_chunks]\n        \n        pivot = recursive_selection(median_values, len(median_values)//2)\n        \n        less_than_pivot = [x for x in subarray if x < pivot]\n        equal_to_pivot = [x for x in subarray if x == pivot]\n        greater_than_pivot = [x for x in subarray if x > pivot]\n        \n        if k < len(less_than_pivot):\n            return recursive_selection(less_than_pivot, k)\n        elif k < len(less_than_pivot) + len(equal_to_pivot):\n            return pivot\n        else:\n            return recursive_selection(greater_than_pivot, k - len(less_than_pivot) - len(equal_to_pivot))\n    \n    return recursive_selection(arr, k)",
        "is_redundant": true,
        "language": "python",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 9,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 30,
            "comparison_loc": 30,
            "differences": [
                "function_names",
                "variable_names",
                "implementation_details"
            ]
        },
        "id": "52"
    },
    {
        "original_code": "#include <vector>\n#include <queue>\n\nclass KthSmallestFinder {\npublic:\n    static int findKthSmallest(std::vector<int>& arr, int k) {\n        std::priority_queue<int> maxHeap;\n        \n        for (int num : arr) {\n            maxHeap.push(num);\n            if (maxHeap.size() > k) {\n                maxHeap.pop();\n            }\n        }\n        \n        return maxHeap.top();\n    }\n\n    static int findKthSmallestOptimized(std::vector<int>& arr, int k) {\n        int n = arr.size();\n        std::vector<int> heap(arr.begin(), arr.begin() + k);\n        \n        std::make_heap(heap.begin(), heap.end());\n        \n        for (int i = k; i < n; ++i) {\n            if (arr[i] < heap.front()) {\n                std::pop_heap(heap.begin(), heap.end());\n                heap.back() = arr[i];\n                std::push_heap(heap.begin(), heap.end());\n            }\n        }\n        \n        return heap.front();\n    }\n}",
        "comparison_code": "#include <vector>\n#include <queue>\n\nclass KthElementSelector {\npublic:\n    static int selectKthElement(std::vector<int>& arr, int k) {\n        std::priority_queue<int> priorityHeap;\n        \n        for (int element : arr) {\n            priorityHeap.push(element);\n            if (priorityHeap.size() > k) {\n                priorityHeap.pop();\n            }\n        }\n        \n        return priorityHeap.top();\n    }\n\n    static int selectKthElementAlternative(std::vector<int>& arr, int k) {\n        int arraySize = arr.size();\n        std::vector<int> heapContainer(arr.begin(), arr.begin() + k);\n        \n        std::make_heap(heapContainer.begin(), heapContainer.end());\n        \n        for (int i = k; i < arraySize; ++i) {\n            if (arr[i] < heapContainer.front()) {\n                std::pop_heap(heapContainer.begin(), heapContainer.end());\n                heapContainer.back() = arr[i];\n                std::push_heap(heapContainer.begin(), heapContainer.end());\n            }\n        }\n        \n        return heapContainer.front();\n    }\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 8,
        "metadata": {
            "source": "custom_generated",
            "original_loc": 35,
            "comparison_loc": 35,
            "differences": [
                "class_names",
                "method_names",
                "variable_names"
            ]
        },
        "id": "53"
    },
    {
        "original_code": "def calculate_area(radius):\n    return 3.14 * radius ** 2",
        "comparison_code": "def calculate_perimeter(radius):\n    return 2 * 3.14 * radius",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 1,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 1,
            "comparison_loc": 1
        },
        "id": "54"
    },
    {
        "original_code": "def sort_numbers(numbers):\n    return sorted(numbers)",
        "comparison_code": "def find_maximum(numbers):\n    return max(numbers)",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 1,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 1,
            "comparison_loc": 1
        },
        "id": "55"
    },
    {
        "original_code": "def greet_user(name):\n    print(f'Hello, {name}!')",
        "comparison_code": "def calculate_sum(a, b):\n    return a + b",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 1,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 1,
            "comparison_loc": 1
        },
        "id": "56"
    },
    {
        "original_code": "def reverse_string(s):\n    return s[::-1]",
        "comparison_code": "def is_palindrome(s):\n    return s == s[::-1]",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 1,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 1,
            "comparison_loc": 1
        },
        "id": "57"
    },
    {
        "original_code": "def read_file(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()",
        "comparison_code": "def write_file(file_path, content):\n    with open(file_path, 'w') as file:\n        file.write(content)",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 2,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 3,
            "comparison_loc": 3
        },
        "id": "58"
    },
    {
        "original_code": "def fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)",
        "comparison_code": "def factorial_iterative(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 5,
            "comparison_loc": 5
        },
        "id": "59"
    },
    {
        "original_code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1",
        "comparison_code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 4,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 20,
            "comparison_loc": 7
        },
        "id": "60"
    },
    {
        "original_code": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1",
        "comparison_code": "class PriorityQueue:\n    def __init__(self):\n        self.queue = []\n\n    def insert(self, data):\n        self.queue.append(data)\n\n    def delete(self):\n        try:\n            max_index = 0\n            for i in range(len(self.queue)):\n                if self.queue[i] > self.queue[max_index]:\n                    max_index = i\n            item = self.queue[max_index]\n            del self.queue[max_index]\n            return item\n        except IndexError:\n            print('Queue is empty')\n            return None",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 5,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 16,
            "comparison_loc": 13
        },
        "id": "61"
    },
    {
        "original_code": "def knapsack(values, weights, capacity):\n    n = len(values)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n\n    return dp[n][capacity]",
        "comparison_code": "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 5,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 12,
            "comparison_loc": 13
        },
        "id": "62"
    },
    {
        "original_code": "def parse_json(json_string):\n    import json\n    try:\n        return json.loads(json_string)\n    except json.JSONDecodeError as e:\n        print(f'Error parsing JSON: {e}')\n        return None",
        "comparison_code": "def connect_to_database(host, user, password, db_name):\n    import pymysql\n    try:\n        connection = pymysql.connect(\n            host=host,\n            user=user,\n            password=password,\n            database=db_name\n        )\n        return connection\n    except pymysql.MySQLError as e:\n        print(f'Error connecting to database: {e}')\n        return None",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 4,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 7,
            "comparison_loc": 9
        },
        "id": "63"
    },
    {
        "original_code": "def detect_cycle(graph):\n    def dfs(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[node] = False\n        return False\n\n    visited = {node: False for node in graph}\n    rec_stack = {node: False for node in graph}\n\n    for node in graph:\n        if not visited[node]:\n            if dfs(node, visited, rec_stack):\n                return True\n    return False",
        "comparison_code": "def topological_sort(graph):\n    def dfs(node, visited, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n        stack.append(node)\n\n    visited = {node: False for node in graph}\n    stack = []\n\n    for node in graph:\n        if not visited[node]:\n            dfs(node, visited, stack)\n\n    return stack[::-1]",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 5,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 19,
            "comparison_loc": 15
        },
        "id": "64"
    },
    {
        "original_code": "def generate_primes(n):\n    primes = []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if sieve[p]:\n            primes.append(p)\n            for i in range(p * p, n + 1, p):\n                sieve[i] = False\n    return primes",
        "comparison_code": "def generate_fibonacci(n):\n    fib_sequence = [0, 1]\n    for _ in range(2, n):\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence[:n]",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 7,
            "comparison_loc": 5
        },
        "id": "65"
    },
    {
        "original_code": "def parse_xml(file_path):\n    import xml.etree.ElementTree as ET\n    try:\n        tree = ET.parse(file_path)\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n        return None",
        "comparison_code": "def parse_csv(file_path):\n    import csv\n    try:\n        with open(file_path, 'r') as csvfile:\n            reader = csv.DictReader(csvfile)\n            return [row for row in reader]\n    except FileNotFoundError as e:\n        print(f'Error reading CSV file: {e}')\n        return []",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 4,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 8,
            "comparison_loc": 7
        },
        "id": "66"
    },
    {
        "original_code": "def train_linear_model(X, y):\n    from sklearn.linear_model import LinearRegression\n    model = LinearRegression()\n    model.fit(X, y)\n    return model",
        "comparison_code": "def train_decision_tree(X, y):\n    from sklearn.tree import DecisionTreeClassifier\n    model = DecisionTreeClassifier()\n    model.fit(X, y)\n    return model",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 5,
            "comparison_loc": 5
        },
        "id": "67"
    },
    {
        "original_code": "def get_weather_data(city):\n    import requests\n    api_url = f'http://api.weather.com/v3/weather/{city}'\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        print('Failed to retrieve data')\n        return None",
        "comparison_code": "def get_stock_prices(stock_symbol):\n    import requests\n    api_url = f'http://api.stocks.com/v2/prices/{stock_symbol}'\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        print('Failed to retrieve data')\n        return None",
        "is_redundant": false,
        "language": "python",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 4,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 8,
            "comparison_loc": 8
        },
        "id": "68"
    },
    {
        "original_code": "int findGCD(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}",
        "comparison_code": "int lcm(int a, int b) {\n    return (a * b) / findGCD(a, b);\n}",
        "is_redundant": false,
        "language": "c++",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 7,
            "comparison_loc": 3
        },
        "id": "69"
    },
    {
        "original_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        int pivot = partition(arr, low, high);\n        quickSort(arr, low, pivot - 1);\n        quickSort(arr, pivot + 1, high);\n    }\n}\n\nint partition(vector<int>& arr, int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}",
        "comparison_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint binarySearch(vector<int>& arr, int low, int high, int key) {\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == key) {\n            return mid;\n        } else if (arr[mid] < key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}",
        "is_redundant": false,
        "language": "c++",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 5,
        "metadata": {
            "source": "manual_entry",
            "original_loc": 19,
            "comparison_loc": 15
        },
        "id": "70"
    },
    {
        "original_code": "void main()\n{\n\tint f(int x,int m);\n\tint k,i,j,n,sum=0;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&k);\n\t\tfor(j=2;j<=k;j++)\n\t\t{\n\t\t\tif(k%j==0)\n\t\t\t{\n\t\t\t\tsum+=f(k,j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t\tsum=0;\n\t}\n}\n\nint f(int x,int m)\n{\n\tint i,sum=0;\n\tif(m==x)\n\t\tsum=1;\n\telse\n\t{\n\t\tx=x/m;\n\t\tfor(i=m;i<=x;i++)\n\t\t{\n\t\t\tif(x%i==0)\n\t\t\t{\n\t\t\t\tsum+=f(x,i);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}",
        "comparison_code": "void main()\n{\n\tint factorCount(int x, int divisor);\n\tint num, i, j, totalSum = 0;\n\tscanf(\"%d\", &num);\n\tfor (i = 1; i <= num; i++)\n\t{\n\t\tint val;\n\t\tscanf(\"%d\", &val);\n\t\tfor (j = 2; j <= val; j++)\n\t\t{\n\t\t\tif (val % j == 0)\n\t\t\t{\n\t\t\t\ttotalSum += factorCount(val, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", totalSum);\n\t\ttotalSum = 0;\n\t}\n}\n\nint factorCount(int x, int divisor)\n{\n\tint sum = 0, i;\n\tif (divisor == x)\n\t\tsum = 1;\n\telse\n\t{\n\t\tx = x / divisor;\n\t\tfor (i = divisor; i <= x; i++)\n\t\t{\n\t\t\tif (x % i == 0)\n\t\t\t{\n\t\t\t\tsum += factorCount(x, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 25,
            "comparison_loc": 25,
            "differences": [
                "function names",
                "variable names"
            ]
        },
        "id": "71"
    },
    {
        "original_code": "void main()\n{\n\tint f(int ,int );\n\tint n[100],sum,i,m;\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++)\n\t\tscanf(\"%d\",&n[i]);\n\tfor(i=0;i<m;i++)\n\t{\n\t\tsum=f(1,n[i])+1;\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}\n\nint f(int i,int n)\n{\n\tint j,k,sum=0;\n\tfor(j=i;j<(int)sqrt((double)n)+1;j++)\n\t{\n\t\tk=sum;\n\t\tif(j==1)sum=0;\n\t\telse\n\t\t{\n\t\t\tif(n%j==0&&n/j>=j)\n\t\t\t{\n\t\t\t\tsum=f(j,n/j)+1;\n\t\t\t}\n\t\t\telse sum=0;\n\t\t}\n\t\tsum=sum+k;\n\t}\n\treturn(sum);\n}",
        "comparison_code": "void computeResults()\n{\n\tint g(int ,int );\n\tint arr[100], result, i, count;\n\tscanf(\"%d\", &count);\n\tfor(i=0; i<count; i++)\n\t\tscanf(\"%d\", &arr[i]);\n\tfor(i=0; i<count; i++)\n\t{\n\t\tresult = g(1, arr[i]) * 2;\n\t\tprintf(\"%d\\n\", result);\n\t}\n}\n\nint g(int i, int num)\n{\n\tint j, factor, total=1;\n\tfor(j=i; j<=num/2; j++)\n\t{\n\t\tfactor = total;\n\t\tif(num % j == 0)\n\t\t{\n\t\t\ttotal += g(j, num/j);\n\t\t}\n\t\ttotal += factor;\n\t}\n\treturn total;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 21,
            "comparison_loc": 21
        },
        "id": "72"
    },
    {
        "original_code": "int fun(int x,int y)\n{\n\tint i,sum=0;\n\tfor(i=x;i*i<=y;i++)\n\t\tif(y%i==0) {sum++;sum+=fun(i,y/i);}\n    return sum;\n}\nint main()\n{\n\tint n,i,sum;\n\tscanf(\"%d\",&n);\n\twhile(n>0)\n\t{ n--;\n\t\tscanf(\"%d\",&i);sum=1;\n\t\tsum+=fun(2,i);\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}",
        "comparison_code": "int compute(int x,int y)\n{\n\tint i,count=0;\n\tfor(i=x;i*i<=y;i++)\n\t\tif(y%i==0) {count++;count+=compute(i,y/i);}\n    return count;\n}\nint main()\n{\n\tint num,i,total;\n\tscanf(\"%d\",&num);\n\twhile(num>0)\n\t{ num--;\n\t\tscanf(\"%d\",&i);total=1;\n\t\ttotal+=compute(2,i);\n\t\tprintf(\"%d\\n\",total);\n\t}\n\treturn 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 15,
            "comparison_loc": 15,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "73"
    },
    {
        "original_code": "int t;\nvoid calc(int a,int d)\n{\n int i;\n if (a==1) t++;\n   else{\n    if (a>=d)\n      for (i=d;i<=a;i++)\n\tif (a%i==0)\n\t  calc(a/i,i);}\n}\nvoid main()\n{\n int n,i,a;\n scanf(\"%d\",&n);\n for (i=1;i<=n;i++)\n   {\n   scanf(\"%d\",&a);\n   t=0;\n   calc(a,2);\n   printf(\"%d\\n\",t);\n   }\n}",
        "comparison_code": "int count;\nvoid factorize(int num, int divisor)\n{\n int i;\n if (num==1) count++;\n   else{\n    if (num>=divisor)\n      for (i=divisor;i<=num;i++)\n\tif (num%i==0)\n\t  factorize(num/i,i);}\n}\nvoid main()\n{\n int cases,i,value;\n scanf(\"%d\",&cases);\n for (i=1;i<=cases;i++)\n   {\n   scanf(\"%d\",&value);\n   count=0;\n   factorize(value,2);\n   printf(\"%d\\n\",count);\n   }\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 17,
            "comparison_loc": 17,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "74"
    },
    {
        "original_code": "int a[1000];\nint l=0,x;\nint fff(int k,int w,int t,int x);\nint main()\n{\n    int i,j,q,p,n,m,y;\n    scanf(\"%d\",&n);\n    for(p=0;p<n;p++)\n       {q=1;l=0;\n        scanf(\"%d\",&x);\n        for(i=2;i<=x;i++)\n           if(x%i==0)\n             {a[q]=i;\n             q++;\n             }\n        fff(1,q-1,1,x);\n        printf(\"%d\\n\",l,x);\n       }\n}\nint fff(int k,int w,int t,int x)\n{\n    int i,j,y,n,m,p;\n      for(i=t;i<=w;i++)\n            {if(x%a[i]==0)\n             {\n             x=x/a[i]; \n             if(x==1){l++;}\n             if(x>1)\n                 fff(k+1,w,i,x);\n             x=x*a[i];\n             }\n            }\n}",
        "comparison_code": "int factorize(int num) {\n    int count = 0;\n    for (int i = 2; i * i <= num; i++) {\n        while (num % i == 0) {\n            count++;\n            num /= i;\n        }\n    }\n    if (num > 1) count++;\n    return count;\n}\nint main() {\n    int n, x;\n    scanf(\"%d\", &n);\n    while (n--) {\n        scanf(\"%d\", &x);\n        printf(\"%d\\n\", factorize(x));\n    }\n    return 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 22,
            "comparison_loc": 12
        },
        "id": "75"
    },
    {
        "original_code": "int main(){\n\tint number(int n, int low);\n\tint n, i, data, ans;\n\tscanf(\"%d\", &n);\n\tfor (i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &data);\n\t\tans = number(data, 2);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\nint number(int n, int low)\n{\n\tint j, ans;\n\tans = 0;\n\tfor (j = low ; j * j<= n; j++)\n\t{\n\t\tif (n % j == 0) \n\t\t\tans = ans + number(n / j, j);\n\t}\n\tans = ans + 1;\n\treturn ans;\n}",
        "comparison_code": "int countDivisors(int num, int divisor) {\n    int count = 0;\n    for (int i = divisor; i * i <= num; i++) {\n        if (num % i == 0) {\n            count += countDivisors(num / i, i);\n        }\n    }\n    return count + 1;\n}\nint main() {\n    int testCases, value;\n    scanf(\"%d\", &testCases);\n    while (testCases--) {\n        scanf(\"%d\", &value);\n        printf(\"%d\\n\", countDivisors(value, 2));\n    }\n    return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 16,
            "comparison_loc": 14,
            "differences": [
                "function_name",
                "variable_names",
                "loop structure"
            ]
        },
        "id": "76"
    },
    {
        "original_code": "int N, A;\n\nint acSearch(int n, int i) {\n\tint ret = 0;\n\n\tif(n == 1) ret = 1;\n\telse for(; i <= n; ++ i)\n\t\tif(n%i == 0) ret += acSearch(n/i, i);\n\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(; N --;) {\n\t\tscanf(\"%d\", &A);\n\t\tprintf(\"%d\\n\", acSearch(A, 2));\n\t}\n\treturn 0;\n}",
        "comparison_code": "int countFactorizations(int num, int factor) {\n    if (num == 1) return 1;\n    int count = 0;\n    for (int i = factor; i <= num; ++i) {\n        if (num % i == 0) {\n            count += countFactorizations(num / i, i);\n        }\n    }\n    return count;\n}\n\nint main() {\n    int cases, value;\n    scanf(\"%d\", &cases);\n    while (cases--) {\n        scanf(\"%d\", &value);\n        printf(\"%d\\n\", countFactorizations(value, 2));\n    }\n    return 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 1,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 14,
            "comparison_loc": 14
        },
        "id": "77"
    },
    {
        "original_code": "int f(int a,int min) {\n\tint j,num;\n\tif (a<min) return 0;\n\tnum=1;\n\tfor (j=min;j<a;j++)\n\t\tif (a%j==0) num=num+f(a/j,j);\n\treturn num;\n}\n\nint main() {\n\tint n,i,out,a;\n\tcin>>n;\n\tfor (i=0;i<n;i++) {\n\t\tcin>>a;\n\t\tout=f(a,2);\n\t\tcout<<out<<endl;\n\t}\n\treturn 0;\n}",
        "comparison_code": "int countWays(int num, int divisor) {\n    if (num < divisor) return 0;\n    int count = 1;\n    for (int i = divisor; i < num; i++) {\n        if (num % i == 0) count += countWays(num / i, i);\n    }\n    return count;\n}\n\nint main() {\n    int testCases, value;\n    cin >> testCases;\n    while (testCases--) {\n        cin >> value;\n        cout << countWays(value, 2) << endl;\n    }\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 14,
            "comparison_loc": 14,
            "differences": [
                "function_name",
                "variable_names"
            ]
        },
        "id": "78"
    },
    {
        "original_code": "int sum(int);\nint g_count, g_j;\nint main() {\n\tint n, a, i;\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tg_count = 0;\n\t\tg_j = 2;\n\t\tcin >> a;\n\t\tcout << sum(a) + 1 << endl;\n\t}\n\treturn 0;\n}\nint sum(int a) {\n\tint i, b;\n\tb = (int)sqrt((double)a);\n\tfor (i = g_j; i <= b; i++) {\n\t\tif (a % i == 0) {\n\t\t\tg_j = i;\n\t\t\tg_count++;\n\t\t\tsum(a / i);\n\t\t}\n\t}\n\treturn g_count;\n}",
        "comparison_code": "int countDivisors(int num) {\n    int count = 0;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            count++;\n            count += countDivisors(num / i);\n        }\n    }\n    return count;\n}\n\nint main() {\n    int testCases, value;\n    cin >> testCases;\n    while (testCases--) {\n        cin >> value;\n        cout << countDivisors(value) + 1 << endl;\n    }\n    return 0;\n}",
        "is_redundant": false,
        "language": "c++",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 17,
            "comparison_loc": 14
        },
        "id": "79"
    },
    {
        "original_code": "int yinshu(int be, int by) {\n    int i, sum = 0;\n    for (i = by; i * i <= be; i++) {\n        if (be % i == 0) {\n            sum += 1 + yinshu(be / i, i);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    int n, i, j, num, sign;\n    cin >> n;\n    for (i = 0; i < n; i++) {\n        cin >> num;\n        for (j = num; j > 1; j--)\n            if (num % j == 0) sign = j;\n        cout << yinshu(num, sign) + 1 << endl;\n    }\n    getchar();\n    getchar();\n    return 0;\n}",
        "comparison_code": "int countFactors(int number, int start) {\n    int count = 0;\n    for (int i = start; i * i <= number; i++) {\n        if (number % i == 0) {\n            count += 1 + countFactors(number / i, i);\n        }\n    }\n    return count;\n}\n\nint main() {\n    int testCases, value;\n    cin >> testCases;\n    while (testCases--) {\n        cin >> value;\n        int highestDivisor = 2;\n        for (int j = value; j > 1; j--) {\n            if (value % j == 0) {\n                highestDivisor = j;\n                break;\n            }\n        }\n        cout << countFactors(value, highestDivisor) + 1 << endl;\n    }\n    return 0;\n}",
        "is_redundant": true,
        "language": "c++",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 16,
            "comparison_loc": 18,
            "differences": [
                "function name",
                "variable names",
                "loop structure"
            ]
        },
        "id": "80"
    },
    {
        "original_code": "void fenjie(int);\n\nint solutionnum = 1;\nint main() {\n    int n, a, i;\n    cin >> n;\n    for (i = 1; i <= n; i++) {\n        cin >> a;\n        fenjie(a);\n        cout << solutionnum << endl;\n        solutionnum = 1;\n    }\n    return 0;\n}\n\nint yinzi[100] = {2}, i = 0;\nvoid fenjie(int x) {\n    int j;\n    for (j = yinzi[i]; j < x; j++) {\n        if (x % j == 0 && x / j >= j) {\n            i++; \n            yinzi[i] = j;\n            fenjie(x / j);\n            j = yinzi[i];\n            i--;\n            solutionnum++;\n        }\n    }\n}",
        "comparison_code": "void decompose(int num);\n\nint ways = 1;\nint main() {\n    int cases, value;\n    cin >> cases;\n    while (cases--) {\n        cin >> value;\n        decompose(value);\n        cout << ways << endl;\n        ways = 1;\n    }\n    return 0;\n}\n\nint factors[100] = {2}, index = 0;\nvoid decompose(int num) {\n    for (int factor = factors[index]; factor < num; factor++) {\n        if (num % factor == 0 && num / factor >= factor) {\n            index++;\n            factors[index] = factor;\n            decompose(num / factor);\n            factor = factors[index];\n            index--;\n            ways++;\n        }\n    }\n}",
        "is_redundant": false,
        "language": "c++",
        "redundancy_type": "distinct_functionality",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 17,
            "comparison_loc": 17
        },
        "id": "81"
    },
    {
        "original_code": "int main() {\n  int m, i, j, k, q = 0, t = 0, u, max;\n  int b[26] = {0};\n  char c[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  struct as {\n    int sh;\n    char a[26];\n  } cla[1000];\n  scanf(\"%d\", &m);\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %s\", &cla[i].sh, cla[i].a);\n    t = (int)strlen(cla[i].a);\n    for (k = 0; k < t; k++) {\n      u = cla[i].a[k] - 'A';\n      b[u]++;\n    }\n  }\n  max = 0;\n  for (j = 0; j < 25; j++)\n    if (max < b[j]) {\n      max = b[j];\n      q = j;\n    }  \n  printf(\"%c\\n\", c[q]);\n  printf(\"%d\\n\", max);\n  for (i = 0; i < m; i++) {\n    t = (int)strlen(cla[i].a);\n    for (k = 0; k < t; k++)\n      if (cla[i].a[k] == c[q])\n        printf(\"%d\\n\", cla[i].sh);\n  }\n  return 0;\n}",
        "comparison_code": "int main() {\n  int n, i, j, k, maxCount = 0, index = 0;\n  int freq[26] = {0};\n  char alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  struct Data {\n    int id;\n    char str[26];\n  } records[1000];\n  \n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %s\", &records[i].id, records[i].str);\n    for (k = 0; records[i].str[k] != '\\0'; k++) {\n      freq[records[i].str[k] - 'A']++;\n    }\n  }\n  \n  for (j = 0; j < 26; j++) {\n    if (freq[j] > maxCount) {\n      maxCount = freq[j];\n      index = j;\n    }\n  }\n  \n  printf(\"%c\\n\", alphabet[index]);\n  printf(\"%d\\n\", maxCount);\n  \n  for (i = 0; i < n; i++) {\n    for (k = 0; records[i].str[k] != '\\0'; k++) {\n      if (records[i].str[k] == alphabet[index]) {\n        printf(\"%d\\n\", records[i].id);\n      }\n    }\n  }\n  \n  return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "functional_duplicate_with_modifications",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 25,
            "comparison_loc": 27,
            "differences": [
                "variable names",
                "loop conditions",
                "function structuring"
            ]
        },
        "id": "82"
    },
    {
        "original_code": "void main()\n{\n\tint a[1000],i,j,m,b[26],t=0,k;\n\tchar c[1000][20];\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++)\n\t\tscanf(\"%d %s\",&a[i],c[i]);\n         for(i=0;i<m;i++)\n\t\tfor(j=0;j<strlen(c[i]);j++)\n\t\t\tif('A'<c[i][j]<'Z') b[c[i][j]-65]++;\n\tfor(i=0;i<26;i++)\n\t\tif(b[i]>t){t=b[i];k=i;}\n\t\tprintf(\"%c\\n\",k+65);\n\t\tprintf(\"%d\\n\",t);\nfor(i=0;i<m;i++)\nfor(j=0;j<strlen(c[i]);j++)\n{\n   if(c[i][j]==k+65) printf(\"%d\\n\",a[i]);\n}\n}",
        "comparison_code": "int main()\n{\n\tint numbers[1000], count[26] = {0}, i, j, maxFreq = 0, maxIndex;\n\tchar words[1000][20];\n\t\n\tscanf(\"%d\", &i);\n\tfor (j = 0; j < i; j++)\n\t{\n\t\tscanf(\"%d %s\", &numbers[j], words[j]);\n\t\tfor (int k = 0; k < strlen(words[j]); k++)\n\t\t{\n\t\t\tif (words[j][k] >= 'A' && words[j][k] <= 'Z')\n\t\t\t\tcount[words[j][k] - 'A']++;\n\t\t}\n\t}\n\n\tfor (j = 0; j < 26; j++)\n\t{\n\t\tif (count[j] > maxFreq)\n\t\t{\n\t\t\tmaxFreq = count[j];\n\t\t\tmaxIndex = j;\n\t\t}\n\t}\n\n\tprintf(\"%c\\n\", maxIndex + 'A');\n\tprintf(\"%d\\n\", maxFreq);\n\n\tfor (j = 0; j < i; j++)\n\t{\n\t\tfor (int k = 0; k < strlen(words[j]); k++)\n\t\t{\n\t\t\tif (words[j][k] == maxIndex + 'A')\n\t\t\t\tprintf(\"%d\\n\", numbers[j]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "optimized_logic_rewrite",
        "complexity_score": 4,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 20,
            "comparison_loc": 23,
            "differences": [
                "logical corrections",
                "variable renaming",
                "structured loops"
            ]
        },
        "id": "83"
    },
    {
        "original_code": "int main()\n{\n    int m,i,j,x,maxnumber;\n    scanf(\"%d\",&m);\n    int booknum[1000];\n    char k[1000][30]; \n    int author[27]={0};\n    for(i=1;i<=m;i++)\n    {\n\t\tscanf(\"%d %s\",&booknum[i],k[i]);\n\t\tfor(j=0;k[i][j]!='\\0';j++)\n\t\t{\n\t\t\tauthor[k[i][j]-'A'+1]++;\n\t\t}\n    }\n    int max=0;\n    for(i=1;i<=26;i++)\n    {\n\t\tif(author[i]>max)\n\t\t{\n\t\t\tmax=author[i];\n\t\t\tmaxnumber=i;\n\t\t}\n    } \n    char who;\n    who='A'+maxnumber-1 ;\n    printf(\"%c\\n\",who);\n    printf(\"%d\\n\",max);\n    for(i=1;i<=m;i++)\n    {\n                     for(j=0;j<strlen(k[i]);j++)\n                     if(k[i][j]==who)\n                     printf(\"%d\\n\",booknum[i]);\n    }\n    return 0; \n}",
        "comparison_code": "int main()\n{\n    int m, i, j, maxCount = 0, maxIndex = 0;\n    scanf(\"%d\", &m);\n    int bookNumbers[1000];\n    char titles[1000][30];\n    int authorFrequency[26] = {0};\n\n    for (i = 0; i < m; i++)\n    {\n        scanf(\"%d %s\", &bookNumbers[i], titles[i]);\n        for (j = 0; titles[i][j] != '\\0'; j++)\n        {\n            authorFrequency[titles[i][j] - 'A']++;\n        }\n    }\n\n    for (i = 0; i < 26; i++)\n    {\n        if (authorFrequency[i] > maxCount)\n        {\n            maxCount = authorFrequency[i];\n            maxIndex = i;\n        }\n    }\n\n    char mostFrequent = 'A' + maxIndex;\n    printf(\"%c\\n%d\\n\", mostFrequent, maxCount);\n\n    for (i = 0; i < m; i++)\n    {\n        for (j = 0; titles[i][j] != '\\0'; j++)\n        {\n            if (titles[i][j] == mostFrequent)\n            {\n                printf(\"%d\\n\", bookNumbers[i]);\n                break;\n            }\n        }\n    }\n    return 0;\n}",
        "is_redundant": true,
        "language": "c",
        "redundancy_type": "variable_offset_fix",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 24,
            "comparison_loc": 27,
            "differences": [
                "indexing correction",
                "variable naming clarity",
                "loop structure optimization"
            ]
        },
        "id": "84"
    },
    {
        "original_code": "void main()\n{\n\tstruct book\n\t{\n\t\tint number;\n\t\tchar author[10];\n\t};\n\tstruct book a[1000];\n\tint i,n,j,count[26]={0},temp,max,index=0;\n\tchar c;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n    scanf(\"%d %s\",&a[i].number,&a[i].author);\n    for(i=0;i<n;i++)\n\t\tfor(j=0;a[i].author[j]!='\\0';j++)\n\t\t{\ttemp=(a[i].author[j])-'A';\n\t\t    count[temp]++;\n\t\t}\n     max=count[0];\n\t for(i=1;i<26;i++)\n\t\t if(count[i]>max)\n\t\t {max=count[i];\n\t\t\t index=i;\n\t\t }\n    c=index+'A';\n\tprintf(\"%c\\n%d\\n\",c,max);\n\t\t for(i=0;i<n;i++)\n\t\t\t for(j=0;a[i].author[j]!='\\0';j++)\n\t\t\t\t if(a[i].author[j]==c)\n\t\t\t\t\t printf(\"%d\\n\",a[i].number);\n}",
        "comparison_code": "int main()\n{\n    struct Book\n    {\n        int number;\n        char author[10];\n    } books[1000];\n\n    int i, n, j, letter_count[26] = {0}, max_count = 0, max_index = 0;\n    char most_frequent_author;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d %s\", &books[i].number, books[i].author);\n        for (j = 0; books[i].author[j] != '\\0'; j++)\n        {\n            letter_count[books[i].author[j] - 'A']++;\n        }\n    }\n\n    for (i = 0; i < 26; i++)\n    {\n        if (letter_count[i] > max_count)\n        {\n            max_count = letter_count[i];\n            max_index = i;\n        }\n    }\n\n    most_frequent_author = 'A' + max_index;\n    printf(\"%c\\n%d\\n\", most_frequent_author, max_count);\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; books[i].author[j] != '\\0'; j++)\n        {\n            if (books[i].author[j] == most_frequent_author)\n            {\n                printf(\"%d\\n\", books[i].number);\n                break;\n            }\n        }\n    }\n    return 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "none",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 23,
            "comparison_loc": 27,
            "differences": [
                "improved struct naming",
                "clearer variable naming",
                "loop optimization"
            ]
        },
        "id": "85"
    },
    {
        "original_code": "main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tstruct \n\t{\n\t\tint num;\n\t\tchar a[25];\n\t}book [999];\n\tint i,j;\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d %s\",&book[i].num,book[i].a);\n\t}\n\tint s[26]={0};\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tint len=strlen(book[i].a);\n\t\tfor(j=0;j<len;j++)\n\t\t{\n\t\t\ts[book[i].a[j]-'A']++;\n\t\t}\n\t}\n\tint max=0;\n\tchar name;\n\tfor(i=0;i<=25;i++)\n\t{\n\t\tif(s[i]>max)\n\t\t{\n\t\t\tmax=s[i];\n\t\t\tname='A'+i;\n\t\t}\n\t}\n\tprintf(\"%c\\n\",name);\n\tprintf(\"%d\\n\",max);\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tint len=strlen(book[i].a);\n\t\tfor(j=0;j<len;j++)\n\t\t{\n\t\t\tif(book[i].a[j]==name)\n\t\t\t\tprintf(\"%d\\n\",book[i].num);\n\t\t}\n\t}\n}",
        "comparison_code": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    \n    struct Book\n    {\n        int number;\n        char author[25];\n    } books[999];\n    \n    int i, j, letter_count[26] = {0}, max_count = 0;\n    char most_frequent_author;\n    \n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d %s\", &books[i].number, books[i].author);\n    }\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; books[i].author[j] != '\\0'; j++)\n        {\n            letter_count[books[i].author[j] - 'A']++;\n        }\n    }\n    \n    for (i = 0; i < 26; i++)\n    {\n        if (letter_count[i] > max_count)\n        {\n            max_count = letter_count[i];\n            most_frequent_author = 'A' + i;\n        }\n    }\n    \n    printf(\"%c\\n%d\\n\", most_frequent_author, max_count);\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; books[i].author[j] != '\\0'; j++)\n        {\n            if (books[i].author[j] == most_frequent_author)\n            {\n                printf(\"%d\\n\", books[i].number);\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "none",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 30,
            "comparison_loc": 33,
            "differences": [
                "structured variable names",
                "loop optimization",
                "improved readability"
            ]
        },
        "id": "86"
    },
    {
        "original_code": "int main()\n{\nstruct book\n{\n    int No;\n    char name[27];\n}b[1000];\n    int i,j,m;\n    scanf(\"%d\",&m);\n    printf(\"\\n\");\n    for(i=0;i<m;i++){\n        scanf(\"%d \",&b[i].No);\n        scanf(\"%s\",b[i].name);\n    }\n    int n,l,a[26]={0};\n    for(i=0;i<m;i++){\n        l=strlen(b[i].name);             \n        for(j=0;j<l;j++){\n            n=b[i].name[j];a[n-65]++;             \n        }             \n    }\n    int max=0,x;\n    for(i=0;i<26;i++){\n        if(a[i]>max){max=a[i];x=i;}              \n    }\n    printf(\"%c\\n%d\",x+65,max);\n    for(i=0;i<m;i++){\n        l=strlen(b[i].name);             \n        for(j=0;j<l;j++){\n            if(b[i].name[j]==x+65){printf(\"\\n%d\",b[i].No);break;}                          \n        } \n    }                \n    return 0;\n}",
        "comparison_code": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n    struct Book\n    {\n        int number;\n        char author[27];\n    } books[1000];\n    \n    int i, j, m, letter_count[26] = {0}, max_count = 0;\n    char most_frequent;\n    \n    scanf(\"%d\", &m);\n    \n    for(i = 0; i < m; i++) {\n        scanf(\"%d %s\", &books[i].number, books[i].author);\n    }\n    \n    for(i = 0; i < m; i++) {\n        for(j = 0; books[i].author[j] != '\\0'; j++) {\n            letter_count[books[i].author[j] - 'A']++;\n        }\n    }\n    \n    for(i = 0; i < 26; i++) {\n        if(letter_count[i] > max_count) {\n            max_count = letter_count[i];\n            most_frequent = 'A' + i;\n        }\n    }\n    \n    printf(\"%c\\n%d\", most_frequent, max_count);\n    \n    for(i = 0; i < m; i++) {\n        for(j = 0; books[i].author[j] != '\\0'; j++) {\n            if(books[i].author[j] == most_frequent) {\n                printf(\"\\n%d\", books[i].number);\n                break;\n            }\n        } \n    }\n    \n    return 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "none",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 30,
            "comparison_loc": 33,
            "differences": [
                "improved struct naming",
                "optimized loops",
                "formatted output"
            ]
        },
        "id": "87"
    },
    {
        "original_code": "void main()\n{\n\tstruct b\n\t{\n\t\tint num;\n\t\tchar str[27];\n\t}b[100];\n\tint n,i,m,j,max,nmax;\n\tint a[26]={0};\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %s\",&b[i].num,b[i].str);\n\t\tm=strlen(b[i].str);\n\t\tfor(j=0;j<m;j++)\n\t\t{\n\t\t\ta[b[i].str[j]-65]++;\n\t\t}\n\t}\n\tmax=a[0];\n\tnmax=0;\n\tfor(i=0;i<26;i++)\n\t{\n\t\tif(a[i]>max) {max=a[i];nmax=i;}\n\t}\n\tprintf(\"%c\\n%d\\n\",nmax+65,max);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tm=strlen(b[i].str);\n\t\tfor(j=0;j<m;j++)\n\t\t{\n\t\t\tif(b[i].str[j]==nmax+65)\n\t\t\t\tprintf(\"%d\\n\",b[i].num);\n\t\t}\n\t}\n}",
        "comparison_code": "#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n\tstruct Book\n\t{\n\t\tint number;\n\t\tchar author[27];\n\t} books[100];\n\t\n\tint n, i, j, max_count = 0, max_index = 0;\n\tint letter_count[26] = {0};\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d %s\", &books[i].number, books[i].author);\n\t\tfor(j = 0; books[i].author[j] != '\\0'; j++)\n\t\t{\n\t\t\tletter_count[books[i].author[j] - 'A']++;\n\t\t}\n\t}\n\t\n\tfor(i = 0; i < 26; i++)\n\t{\n\t\tif(letter_count[i] > max_count) {\n\t\t\tmax_count = letter_count[i];\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\t\n\tprintf(\"%c\\n%d\\n\", max_index + 'A', max_count);\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tfor(j = 0; books[i].author[j] != '\\0'; j++)\n\t\t{\n\t\t\tif(books[i].author[j] == max_index + 'A')\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", books[i].number);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "c",
        "redundancy_type": "none",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 30,
            "comparison_loc": 33,
            "differences": [
                "improved struct naming",
                "fixed incorrect array initialization",
                "optimized loop conditions",
                "fixed printf formatting"
            ]
        },
        "id": "88"
    },
    {
        "original_code": "int main() \n{\n\tint n , number , i , j , k , t , len , max;\n\tint map[26][1000] = {0};\n\tchar name[27];\n\n\tcin >> n;\n\tfor (i = 0; i <= 25; i++)\n\t\tmap[i][0] = 0;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tcin >> number >> name;\n        len = strlen(name);\n\t\tfor (j = 0; j <= len - 1; j++)\n\t\t{\n\t\t\tk = name[j] - 'A';\n            map[k][0]++;\n\t\t\tt = map[k][0];\n\t\t\tmap[k][t] = number;\n\t\t}\n\t}\n\tmax = 0;\n\tfor (i = 0; i <= 25; i++)\n\t{\n\t\tif (map[i][0] > max)\n\t\t{\n\t\t\tmax = map[i][0];\n\t\t\tk = i;\n\t\t}\n\t}\n\tcout << (char)(65 + k) << endl;\n\tcout << map[k][0];\n\tfor (i = 1; i <= map[k][0]; i++)\n\t\tcout << endl << map[k][i];\n\t\n\treturn 0;\n}",
        "comparison_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n, number, i, j, k, len, max_index = 0;\n    int letter_count[26] = {0};\n    int book_numbers[26][1000] = {0};\n    char name[27];\n\n    cin >> n;\n    for (i = 0; i < n; i++) {\n        cin >> number >> name;\n        len = strlen(name);\n        for (j = 0; j < len; j++) {\n            k = name[j] - 'A';\n            book_numbers[k][++letter_count[k]] = number;\n        }\n    }\n\n    for (i = 0; i < 26; i++) {\n        if (letter_count[i] > letter_count[max_index]) {\n            max_index = i;\n        }\n    }\n\n    cout << char(max_index + 'A') << endl;\n    cout << letter_count[max_index] << endl;\n    for (i = 1; i <= letter_count[max_index]; i++) {\n        cout << book_numbers[max_index][i] << endl;\n    }\n    \n    return 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "none",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 31,
            "comparison_loc": 34,
            "differences": [
                "improved variable naming",
                "removed unnecessary loop initializations",
                "simplified nested indexing",
                "replaced manual mapping with clearer array access"
            ]
        },
        "id": "89"
    },
    {
        "original_code": "int main()\n{\n    int n,i,j;\n    cin >> n;\n    char number[1000][5]={' '};\n    char authors[1000][30]={' '};\n    int author[30]={0};\n    for (i=0;i<=n-1;i++)\n    {\n        cin >> number[i] >> authors[i];\n        int len1=strlen(authors[i]);\n        \n        for (j=0;j<=len1-1;j++)\n        {\n            author[authors[i][j]-'A']++;\n        }\n    }\n    int k,kmax=0; \n    int max=author[0];\n    for (k=1;k<=25;k++)\n    {\n        if (author[k]>max)\n        {\n            max=author[k];\n            kmax=k;\n        }\n    }\n    char writer=kmax+'A';\n    cout << writer << endl;\n    cout << max << endl;\n    for (i=0;i<=n-1;i++)\n    {\n        for (j=0;j<=25;j++)\n        {\n            if (authors[i][j]-'A'==kmax)\n            {\n                cout << number[i] << endl;\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}",
        "comparison_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    int n, i, j, max_count = 0, max_author = 0;\n    char number[1000][5], authors[1000][30];\n    int author_freq[26] = {0};\n\n    cin >> n;\n    for (i = 0; i < n; i++) {\n        cin >> number[i] >> authors[i];\n        int len = strlen(authors[i]);\n        for (j = 0; j < len; j++) {\n            author_freq[authors[i][j] - 'A']++;\n        }\n    }\n    \n    for (i = 0; i < 26; i++) {\n        if (author_freq[i] > max_count) {\n            max_count = author_freq[i];\n            max_author = i;\n        }\n    }\n    \n    char most_common_author = max_author + 'A';\n    cout << most_common_author << endl << max_count << endl;\n    \n    for (i = 0; i < n; i++) {\n        if (strchr(authors[i], most_common_author)) {\n            cout << number[i] << endl;\n        }\n    }\n    \n    return 0;\n}",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "loop inefficiency",
        "complexity_score": 4,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 35,
            "comparison_loc": 32,
            "differences": [
                "Optimized array indexing",
                "Reduced redundant loop iterations",
                "Used built-in function strchr for character search"
            ]
        },
        "id": "90"
    },
    {
        "original_code": "int main(int argc, char* argv[])\n{\n\tint a,b,c[1001],i,j,m=1;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(i=0;i<a;i++){\n\t\tscanf(\"%d\",&c[i]);\n\t}\n\tfor(i=0;i<a;i++){\n\t\tif(m==0) break;\n\t\tfor(j=0;j<a&&j!=i;j++){\n\t\t\tif(c[i]+c[j]==b) { \n\t\t\t\tprintf(\"yes\");\n\t\t\t\tm=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(m==1) printf(\"no\");\n\treturn 0;\n}",
        "comparison_code": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    int n, target;\n    cin >> n >> target;\n    int arr[n];\n    unordered_set<int> seen;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        if (seen.count(target - arr[i])) {\n            cout << \"yes\";\n            return 0;\n        }\n        seen.insert(arr[i]);\n    }\n    cout << \"no\";\n    return 0;\n}",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "inefficient brute force",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 16,
            "comparison_loc": 14,
            "differences": [
                "Optimized O(n^2) brute-force approach to O(n) using a hash set",
                "Eliminated unnecessary loops",
                "Improved readability using modern C++ features"
            ]
        },
        "id": "91"
    },
    {
        "original_code": "void main(){\n\tint n,i,k,m[1000],s=0,j;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&m[i]);\n\t\tfor(j=i-1;j>=0;j--){\n\t\t\tif(m[i]+m[j]==k)\n\t\t\t\ts++;\n\t\t}\n\t}\n\tif(s>0)\n\t\tprintf(\"yes\");\n\telse\n\t\tprintf(\"no\");\n}",
        "comparison_code": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    unordered_set<int> seen;\n    \n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n        if (seen.count(k - num)) {\n            cout << \"yes\";\n            return 0;\n        }\n        seen.insert(num);\n    }\n    cout << \"no\";\n    return 0;\n}",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "inefficient nested loop",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 13,
            "comparison_loc": 14,
            "differences": [
                "Replaced O(n^2) nested loops with O(n) unordered_set lookup",
                "Eliminated unnecessary iteration over previous elements",
                "Improved readability with modern C++ features"
            ]
        },
        "id": "92"
    },
    {
        "original_code": "int main(){\n\tint n,k,i,j,flag =1,first = 0;\n\tint num[1000]={0},sub=0;\n\tscanf(\"%d%d\", &n,&k);\n\tfor(i = 0;i<n;i++){\n\t\tscanf(\"%d\", &num[i]);\n\t}\n\tfor(i = 0;i<n;i++){\n\t    sub = k - num[i];\n\t\tfor(j = i +1;j<n;j++){\n\t\t\tif(sub == num[j]){\n\t\t\t\tflag = 0;\n\t\t\t\tfirst =1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(first)\n\t\t\tbreak;\n\t}\n\tif(flag)\n\t\tprintf(\"no\");\n\telse\n\t\tprintf(\"yes\");\n\treturn 0;\n}",
        "comparison_code": "int main(){\n\tint n,k,i,j,flag =1,first = 0;\n\tint num[1000]={0},sub=0;\n\tscanf(\"%d%d\", &n,&k);\n\tfor(i = 0;i<n;i++){\n\t\tscanf(\"%d\", &num[i]);\n\t}\n\tfor(i = 0;i<n;i++){\n\t    sub = k - num[i];\n\t\tfor(j = i +1;j<n;j++){\n\t\t\tif(sub == num[j]){\n\t\t\t\tflag = 0;\n\t\t\t\tfirst =1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(first)\n\t\t\tbreak;\n\t}\n\tif(flag)\n\t\tprintf(\"no\");\n\telse\n\t\tprintf(\"yes\");\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "N/A",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 19,
            "comparison_loc": 19,
            "differences": []
        },
        "id": "93"
    },
    {
        "original_code": "int main(int argc, char* argv[])\n{\n\tint n, k, a[1000], b=0, i;\n\tscanf(\"%d %d\\n\", &n, &k);\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\tif(a[i]+a[j]==k){\n\t\t\t\tb=1;\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b==1){\n\t\t\tbreak;}\n\t}\n\tif(b==0){\n\t\tprintf(\"no\\n\");}\n\n\treturn 0;\n}",
        "comparison_code": "int main(int argc, char* argv[])\n{\n\tint n, k, a[1000], b=0, i;\n\tscanf(\"%d %d\\n\", &n, &k);\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\tif(a[i]+a[j]==k){\n\t\t\t\tb=1;\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b==1){\n\t\t\tbreak;}\n\t}\n\tif(b==0){\n\t\tprintf(\"no\\n\");}\n\n\treturn 0;\n}",
        "is_redundant": true,
        "language": "cpp",
        "redundancy_type": "Exact Duplicate",
        "complexity_score": 1,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 19,
            "comparison_loc": 19,
            "differences": []
        },
        "id": "94"
    },
    {
        "original_code": "void main()\n{\n\tint n, i, j, k, number[1000], flag=0;\n\tscanf(\"%d%d\", &n, &k);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\", &number[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i != j){\n\t\t\t\tif(number[i]+number[j] == k)\n\t\t\t\t\tflag++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\tif(flag != 0)\n\t\tprintf(\"yes\");\n\telse\n\t\tprintf(\"no\");\n}",
        "comparison_code": "void main()\n{\n\tint n, k, i, num;\n\tint hash[100000] = {0}; // Assuming reasonable input range\n\tscanf(\"%d%d\", &n, &k);\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%d\", &num);\n\t\tif(hash[k - num]){\n\t\t\tprintf(\"yes\");\n\t\t\treturn;\n\t\t}\n\t\thash[num] = 1;\n\t}\n\tprintf(\"no\");\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Algorithmic Variation",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 17,
            "comparison_loc": 12,
            "differences": [
                "Uses hash table for O(n) solution instead of nested loops"
            ]
        },
        "id": "95"
    },
    {
        "original_code": "int main()\n{\n\tint *array, n, k, i, j;\n\tscanf(\"%d%d\",&n,&k);\n\tarray=(int*)malloc(sizeof(int)*n);\n\n\tfor (i=0;i<n;i++)\n\t\tscanf(\"%d\",array+i);\n\tfor(i=0;i<n-1;i++)\n\t\tfor(j=i+i;j<n;j++)\n\t\t\tif (array[i]+array[j]==k)\n\t\t\t{\n\t\t\t\tprintf(\"yes\");\n\t\t\t\tfree(array);\n\t\t\t\treturn 0;\n\t\t\t}\n\tfree(array);\n\tprintf(\"no\");\n\treturn 0;\n}",
        "comparison_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int *array, n, k, i, left, right;\n    scanf(\"%d%d\", &n, &k);\n    array = (int*)malloc(sizeof(int) * n);\n\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &array[i]);\n\n    qsort(array, n, sizeof(int), compare);\n\n    left = 0;\n    right = n - 1;\n    \n    while (left < right) {\n        int sum = array[left] + array[right];\n        if (sum == k) {\n            printf(\"yes\");\n            free(array);\n            return 0;\n        }\n        else if (sum < k)\n            left++;\n        else\n            right--;\n    }\n\n    free(array);\n    printf(\"no\");\n    return 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Algorithmic Variation",
        "complexity_score": 3,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 17,
            "comparison_loc": 26,
            "differences": [
                "Uses sorting and two-pointer technique instead of brute-force"
            ]
        },
        "id": "96"
    },
    {
        "original_code": "int main()\n{\n\tint k,i,n,j,count,r=0;\n\tint a[1000];\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\tfor(j=i+1;j<n;j++)\n\t\t{\n\t\t\tcount=a[i]+a[j];\n\t\t\tif(count==k)\n\t\t\t{\n\t\t\t\tprintf(\"yes\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(count!=k)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\tif(count==k)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(r==(n*(n-1)/2)&&(a[n-1]+a[n-2])!=k)\n\t{\n\t\tprintf(\"no\");\n\t}\n\treturn 0;\n}",
        "comparison_code": "#include <stdio.h>\n\nint main() {\n    int k, i, n, j;\n    int a[1000];\n    scanf(\"%d%d\", &n, &k);\n    \n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n\n    for (i = 0; i < n - 1; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (a[i] + a[j] == k) {\n                printf(\"yes\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"no\");\n    return 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Code Simplification",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 21,
            "comparison_loc": 15,
            "differences": [
                "Removes redundant checks and manual count tracking"
            ]
        },
        "id": "97"
    },
    {
        "original_code": "int main()\n{\n\tint n , k , a[1000] , YN = 0;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i = 0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int j = 0;j<n-1;j++)\n\t{\n\t\tfor(int m = j;m<n;m++)\n\t\t{\n\t\t\tint he = a[j] + a[m];\n\t\t\tif(he == k)\n\t\t\t{\n\t\t\t\tYN = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(YN == 1)\n\t\tprintf(\"yes\");\n\telse if(YN == 0)\n\t\tprintf(\"no\");\n\treturn 0;\n}",
        "comparison_code": "int main()\n{\n\tint n, k, a[1000];\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int j = 0; j < n - 1; j++)\n\t{\n\t\tfor (int m = j + 1; m < n; m++)\n\t\t{\n\t\t\tif (a[j] + a[m] == k)\n\t\t\t{\n\t\t\t\tprintf(\"yes\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"no\");\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Code Simplification",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 21,
            "comparison_loc": 17,
            "differences": [
                "Removes unnecessary `YN` flag",
                "Fixes incorrect inner loop range (`m = j + 1` instead of `m = j`)",
                "Directly prints `yes` and exits upon finding a valid pair"
            ]
        },
        "id": "98"
    },
    {
        "original_code": "void main()\n{\n\tint n,k,m=0;\n\tint a[1000];\n\tint i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<n;i++)\n\t\tfor(j=1;j<n-i;j++)\n\t\t\tif(a[i]+a[i+j]==k)\n\t\t\t\tm++;\n\n    if(m)\n\t\tprintf(\"yes\");\n\telse\n\t\tprintf(\"no\");\n\n}",
        "comparison_code": "int main()\n{\n\tint n, k, a[1000];\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (a[i] + a[j] == k)\n\t\t\t{\n\t\t\t\tprintf(\"yes\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"no\");\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Loop Optimization",
        "complexity_score": 2,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 15,
            "comparison_loc": 17,
            "differences": [
                "Changes nested loop condition to `j = i + 1` for correctness",
                "Exits immediately upon finding a valid pair instead of counting",
                "Removes unnecessary variable `m`"
            ]
        },
        "id": "99"
    },
    {
        "original_code": "int main ()\n{\n\tint a[1000],i,j,n,k;\n\tint x=0,y=0;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\tfor(j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(a[i]+a[j]==k) \n\t\t\t{\n\t\t\t\tx=1;\n\t\t\t\ty=1;\n\t\t\t}\n\t\t\tif(x==1) break;          \n\t\t}\n\t\tif(y==1) break;\n\t}\n\tif(x==1) printf(\"yes\");\n\tif(x==0) printf(\"no\");\n\treturn 0;\n}",
        "comparison_code": "int main ()\n{\n\tint a[1000], i, j, n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tfor(j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(a[i] + a[j] == k) \n\t\t\t{\n\t\t\t\tprintf(\"yes\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"no\");\n\treturn 0;\n}",
        "is_redundant": false,
        "language": "cpp",
        "redundancy_type": "Variable Removal",
        "complexity_score": 1,
        "metadata": {
            "source": "dataset_conversion",
            "original_loc": 19,
            "comparison_loc": 17,
            "differences": [
                "Removed unnecessary variables `x` and `y`",
                "Directly returned upon finding a valid pair instead of using flags"
            ]
        },
        "id": "100"
    }
]